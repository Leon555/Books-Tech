<html>
<head>
  <title>Nginx--整理</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="3499"/>
<h1>Nginx--整理</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><span style="font-family: 微软雅黑;">Nginx如何处理请求？</span></div><div><span style="font-family: 微软雅黑;">第一步：核心模块（<b>准备worker进程，获得监听套接字</b>）</span></div><div><span style="font-family: 微软雅黑;">0 建立worker进程，使获得锁的进程，监听端口。</span></div><div><font face="微软雅黑">第二步：事件模块 （<b>分阶段建立连接、选择进入HTTP模块 还是 添加定时器</b>）</font></div><div>1 <b>建立TCP连接</b>：分成SYN到达事件、ACK到达事件。每次事件到达时，将它加入到epoll_ctl机制的红黑树事件中，然后等待epoll_wait的调用。</div><div>2 连接建立后，得到已连接的socket句柄，但是此时并<b>不将连接加到事件驱动器</b>中，<b>调用ngx_http_init_connection</b>中：</div><div>     若可读调用ngx_http_init_request()；若不可读,添加定时器。（<b>只有真的有数据在连接上进行才处理</b>）</div><div>第三步：HTTP模块（<b>HTTP开始行、首部、主体进行解析</b>、<b>业务逻辑处理（server、location定位、访问控制、产生响应并发送、日志记录）</b>）</div><div>3 一个链接建立并有数据可读的入口ngx_http_init_request()，用于初始化<b>ngx_request_t</b>结构。</div><div>4 <b>解析HTTP的开始行</b>：ngx_http_process_request_line()，<b>操作方法</b>（GET、POST）空格<b>URL</b>空格<b>版本</b>回车换行</div><div>5 解析HTTP头部：格式（<b>名称：</b>空格<b>值</b>）【Host： 主机域名】 【User-Agent： 表明用户代理是使用什么浏览器】 【Accept-Language： 】  与主体之间有一个换行。</div><div>  两个回车换行符表示解析结束。</div><div>6 从<b>业务上真正的处理该请求</b>：ngx_http_core_run_phrases(),将<b>一个HTTP请求的处理分为多个阶段（灵活、简单、可扩展、</b><span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left;"><b>开发者可以很容易分辨自己需要开发的模块应该定义在什么阶段</b></span><b>）</b>，这个函数就是用来执行这些不同的阶段；并产生相应数据，把它放在ngx_request_t中的headers_out中。<b>各阶段</b>:</div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;">1 NGX_HTTP_POST_READ_PHASE： 接收完请求头之后的第一个阶段，它位于uri重写之前，实际上很少有模块会注册在该阶段，默认的情况下，该阶段被跳过；<br/>
2 <b>找server：</b>NGX_HTTP_SERVER_REWRITE_PHASE： server级别的uri重写阶段，也就是该阶段执行处于server块内，location块外的重写指令，前面的章节已经说明在读取请求头的过程中nginx会根据host及端口找到对应的虚拟主机配置；<br/>
3 <b>找location：</b>NGX_HTTP_FIND_CONFIG_PHASE： 寻找location配置阶段，该阶段使用重写之后的uri来查找对应的location，值得注意的是该阶段可能会被执行多次，因为也可能有location级别的重写指令；<br/>
4 <b>重写location级别Uri：</b>NGX_HTTP_REWRITE_PHASE： location级别的uri重写阶段，该阶段执行location基本的重写指令，也可能会被执行多次；<br/>
5 <b>找到location：</b>NGX_HTTP_POST_REWRITE_PHASE： location级别重写的后一阶段，用来检查上阶段是否有uri重写，并根据结果跳转到合适的阶段；<br/>
6 <b>访问控制：</b>NGX_HTTP_PREACCESS_PHASE： 访问权限控制的前一阶段，该阶段在权限控制阶段之前，一般也用于访问控制，比如限制访问频率，链接数等；<br/>
7 <b>访问控制：</b>NGX_HTTP_ACCESS_PHASE： 访问权限控制阶段，比如基于ip黑白名单的权限控制，基于用户名密码的权限控制等；<br/>
8 <b>根据权限处理：</b>NGX_HTTP_POST_ACCESS_PHASE： 访问权限控制的后一阶段，该阶段根据权限控制阶段的执行结果进行相应处理；<br/>
9 NGX_HTTP_TRY_FILES_PHASE： try_files指令的处理阶段，如果没有配置try_files指令，则该阶段被跳过；<br/>
10 <b>产生内容并发送：</b>NGX_HTTP_CONTENT_PHASE：内容生成阶段，该阶段产生响应，并发送到客户端；<br/>
11 <b>日志记录：</b>NGX_HTTP_LOG_PHASE： 日志记录阶段，该阶段记录访问日志；</blockquote><div>7 HTTP响应报文：状态行：（<b>版本</b>空格<b>状态码</b>空格<b>简单短语</b>）</div><div><br/></div><div>server：多个主机域名对应同一个ip地址，此时每一个server块为一个虚拟主机，只处理与之对应的主机域名请求。</div><div>URI ：Uniform Resource Identifier，通用资源标识符；URL：Uniform Resource Locator，统一资源定位符；URN：Uniform Resource Name，统一资源名称。<br/>
其中，URL,URN是URI的子集。Web上地址的基本形式是URI,它代表通用资源标识符。有两种形式：<br/>
URL：目前URI的最普遍形式就是无处不在的URL或统一资源定位器。<br/>
URN：URL的一种更新形式，统一资源名称(URN, Uniform Resource Name)不依赖于位置，并且有可能减少失效连接的个数。但是其流行还需假以时日，因为它需要更精密软件的支持。<br/>
URI是以某种统一的（标准化的）方式标识资源的简单字符串。</div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b><br/></b></div><div><b>学习Nginx的原因</b>：1.Nginx是一个优秀的web服务器，研究源代码，非常的有意义。2.扩展下自己的视野，因为自己在研究生阶段做的项目都是偏过程化、功能化的，一般以功能驱动型进行开发，并不知道大中型软件的设计。</div><div><br/></div><div><b>你从中学到了什么？</b></div><div>1 代码的规范性、模块化、可扩展。</div><div>2 进程模型、进程通信、内存池设计。</div><div><br/></div><div><b>你是怎么分析开源代码的？</b></div><div><br/></div><div><br/></div><div><br/></div><div><b>你遇到过什么问题吗？怎么解决的？</b></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><b>Nginx定义：</b></div><div>是一个十分轻量级的HTTP服务器、反向代理服务器。以事件驱动的方式编写，所以性能非常的好。</div><div><br/></div><div><b>web服务器定义：</b>以统一资源描述符作为沟通依据，通过HTTP为浏览器等客户端提供各种网络服务。Apache、lighttpd、tomcat、jetty、IIS。</div><div><br/></div><div><hr/></div><div><b><font color="#FF0000">Nginx特点、优越性</font></b></div><div>web服务器约束：性能（网络性能、单词请求延迟性）、可扩展性、可移植性、可靠性。</div><div><br/></div><div><b>可扩展性：</b>非常便利使用Nginx框架进行<b>二次开发</b>：</div><div>     （1）<b><font color="#FF0000">高度模块化设计</font></b>，可以轻松的复用各种已有模块（配置、日志记录、HTTP、mail等模块）</div><div>     （2）服务器进程的管理上优秀（进程模型）：动态升级，子进程的监控、管理</div><div>     （3）充分考虑不同操作系统的擅长（事件模块的不同）</div><div>     （4）封装了许多平台无关的的接口、容器（双向链表、动态数组）</div><div><br/></div><div><b>高性能<font color="#FF0000">快</font>（事件模型、进程模型、内存分配）：</b>（<b>处理速度</b>快和<b>资源占用</b>小是典型特性，尤其是当服务器遇到<span lang="EN-US">C10K</span>问题的时候）</div><div>1 <b>post机制</b>：解决惊群问题时，拿到锁的进程对<b>锁的释放时机</b>。以及一般情况下也不用信号量互斥锁。</div><div>2 并发模型的设计相当重要。设置CPU个数的进程数，每个进程处理上万个链接。用这样的进程模型取代每个连接一个进程的方式，<b>减少进程间的切换</b>。</div><div>3 在linux使用epoll事件模型</div><div>4 基于磁盘的异步IO，也就是说，当前进程调用磁盘IO函数时，并不死等结果，而是让系统内核处理好数据后，收到信号再处理该ＩＯ事件。</div><div>５<span style="line-height: 22.68000030517578px;">支持mmap内存映射，mmap传统的web服务器，进行页面输入时，都是将磁盘的页面先输入到内核缓存中，再由内核缓存中复制一份到web服务器上，mmap机制就是让内核缓存与磁盘进行映射，web服务器，直接复制页面内容即可。不需要先把磁盘的上的页面先输入到内核缓存去。</span></div><div>6 <b>连接池，事件池</b>（一一对应）：由全局的ngx_cycle_t中的两个链表connections和free_connections组成。大小可由配置项初始化</div><div>7 低内存消耗：10000个非活跃HTTP keep-alive连接只要2.5MB内存。</div><div>8 单机支持 10万以上的并发连接。</div><div><br/></div><div><a href="http://www.cricode.com/2962.html">http://www.cricode.com/2962.html</a></div><div><br/></div><div><hr/><b><font color="#FF0000">Nginx模块架构</font></b></div><div><br/></div><div><br/></div><div>1 <b><font color="#FF0000">每个模块都包含ngx_module_t结构体</font></b>，包括每个模块的具体信息结构指针<b>void *</b>ctx、每个模块处理配置项的方法<b>ngx_command_t</b>、本模块的初始化与结束退出。用一个全局的ngx_module_s结构指针数组记住每一个模块。根据ctx指针可以访问到具体模块类型，每个模块将ctx<b>具体化为ngx_xxx_module_t</b>类型，<b>（或者是具体化为ngx_core_module_t类型，针对核心类型模块）</b>该类型提供本模块的配置项结构生成及初始化、一些公用接口。</div><div><br/></div><div>2 基础核心类型模块的细分：<b>ngx_core_module,ngx_errlog_module,ngx_events_module,ngx_openssl_module,ngx_http_module,ngx_mail_module</b>。定义这些<b>核心模块的作用</b>是 使得非模块化的框架代码只需要关注如何调用这6个核心模块。</div><div>根据核心模块进行分工处理，事件处理有ngx_events_module处理，所有HTTp类型的模块由ngx_http_module模块管理。</div><div><br/></div><div>3 多层次、分类别的模块化设计（类别模块）：<b>核心模块、配置模块（由框架代码定义）</b>、事件模块、HTTP模块、mail模块</div><div><br/></div><div><br/></div><div><br/></div><div><hr/></div><div><b><font color="#FF0000">进程模型，优点</font></b></div><div>1 一个<b>master管理进程</b>、多个<b>完全相同</b>的<b>worker进程</b>、可选的cache manager进程和cache loader进程。</div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div><b>master进程作用：</b>主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当 worker进程退出后(异常情况下)，会自动重新启动新的worker进程。<span style="line-height: 22px;">读取并验正配置信息；</span><span style="line-height: 22px;">创建、绑定及关闭套接字；</span></div><div><b>worker进程作用：</b>处理基本的网络事件。<span style="line-height: 22px;">接收、传入并处理来自</span><span style="line-height: 22px; margin: 0px; padding: 0px;"><a href="http://cpro.baidu.com/cpro/ui/uijs.php?rs=1&amp;amp;amp;u=http%3A%2F%2Fwww%2Ejuziku%2Ecom%2Fwiki%2F15028%2Ehtm&amp;amp;amp;p=baidu&amp;amp;amp;c=news&amp;amp;amp;n=10&amp;amp;amp;t=tpclicked3_hc&amp;amp;amp;q=sunlightcs_cpr&amp;amp;amp;k=%BF%CD%BB%A7%B6%CB&amp;amp;amp;k0=%BF%CD%BB%A7%B6%CB&amp;amp;amp;k1=windows&amp;amp;amp;k2=linux&amp;amp;amp;k3=%B2%CD%B9%DD&amp;amp;amp;k4=%D0%E9%C4%E2%D6%F7%BB%FA&amp;amp;amp;k5=%C4%A3%D0%CD&amp;amp;amp;sid=a919daecc4a04ade&amp;amp;amp;ch=0&amp;amp;amp;tu=u1682495&amp;amp;amp;jk=f850946f9e8c2449&amp;amp;amp;cf=29&amp;amp;amp;fv=14&amp;amp;amp;stid=9&amp;amp;amp;urlid=0&amp;amp;amp;luki=7&amp;amp;amp;seller_id=1&amp;amp;amp;di=128" style="margin: 0px; padding: 0px; text-decoration: none;" target="_blank"><span style="margin: 0px; padding: 0px; color: rgb(0, 0, 255);">客户端</span></a></span><span style="line-height: 22px;">的连接；</span><span style="line-height: 22px;">提供反向代理及过滤功能；</span><span style="line-height: 22px;">nginx任何能完成的其它任务；</span></div><div><br/></div></blockquote><div>2 多个worker进程带来的优点：</div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>1） 利用多核系统的并发能力；进程间地位平等不会出现某一级的进程成为瓶颈。</div><div>2） 负载均衡：多个worker进程间通过进程间通信来实现负载均衡。</div></blockquote><div>3 master进程带来的优点：</div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>3） master进程充当整个进程组与用户的交互接口，负责监控工作进程的状态，并负责管理其行为；当工作进程出现问题时，master进程可以重新启动一个工作进程来避免系统性能的下降。</div><div>4） master进程支持平滑升级、配置项修改的能力。</div></blockquote><div><br/></div><div>设置worker的个数为cpu的核数，在这里就很容易理解了，更多的worker数，只会导致进程来竞争cpu资源了，从而带来不必要的上下文切换。</div><div><div>如果负载以CPU密集型应用为主，如SSL或压缩应用，则worker数应与CPU数相同；如果负载以IO密集型为主，如响应大量内容给客户端，则worker数应该为CPU个数的1.5或2倍。</div><br/></div><div><p style="TEXT-INDENT: 15.8pt; MARGIN: 0cm 0cm 0pt; BACKGROUND: #8db3e2; mso-char-indent-count: 1.5; mso-background-themecolor: text2; mso-background-themetint: 102;"><span lang="EN-US">worker</span>进程的事件循环就是监听网络事件并处理（如新建连接、断开连接、处理请求、发送响应等），所以真正的连接最终是连到了<span lang="EN-US">worker</span>进程，但是<span lang="EN-US">worker</span>进程之间是怎么调用<span lang="EN-US">accept()</span>函数呢？</p><p style="TEXT-INDENT: 21pt; MARGIN: 0cm 0cm 0pt; BACKGROUND: #8db3e2; mso-char-indent-count: 2.0; mso-background-themecolor: text2; mso-background-themetint: 102;">所有的<span lang="EN-US">worker</span>进程都有监听套接字，都能够<span lang="EN-US">accept</span>一个连接，但是<span lang="EN-US">nginx</span>准备了一个<span lang="EN-US">accept</span>锁，因此所有的子进程在走到处理新连接这一步的时候都要争下<span lang="EN-US">accept</span>锁，争到锁的<span lang="EN-US">worker</span>进程可以调用<span lang="EN-US">accept()</span>并接受新连接。</p><p style="TEXT-INDENT: 21pt; MARGIN: 0cm 0cm 0pt; BACKGROUND: #8db3e2; mso-char-indent-count: 2.0; mso-background-themecolor: text2; mso-background-themetint: 102;">这样做的目的就是为了防止多个进程同时<span lang="EN-US">accept</span>，当一个连接来的时候多个进程同时被唤起，即惊群。</p></div><div><a href="http://cjhust.blog.163.com/blog/static/17582715720121274746505/">http://cjhust.blog.163.com/blog/static/17582715720121274746505/</a> </div><div><strong><br/></strong></div><div><strong>多线程模型 VS 多进程模型</strong></div><div> nginx采用这种进程模型有什么好处：</div><div>1  对于每个worker进程来说，独立的进程，不需要加锁，所<b>以省掉了锁带来的开销</b>，同时在编程以及问题查找时，也会方便很多。</div><div>2 独立的进程，一个进程退出后，其它进程正常工作。</div><div><br/></div><div><a href="http://www.cricode.com/2962.html">http://www.cricode.com/2962.html</a> </div><div><br/></div><div><b><font color="#FF0000">进程通信</font></b></div><div><b>1 管道</b>（Pipe）及有名管道（named pipe <b>FIFO</b>）：管道可用于具有<b>亲缘关系</b>进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许<b>无亲缘关系</b>进程间的通信。</div><div><b>无名管道：</b>int pipe(int filedes[2]); //filedes[0]为读</div><div><b>有名管道</b>：int mkfifo(const char *pathname,mode_t mode);可用于进程间的非线性连接，所以可用于客户进程/服务器进程之间的通信（大家都往众所周知的FIFO写，再维护一个独立客户进程与服务器进程间的FIFO）</div><div><b><br/></b></div><div><b>2 信号</b>（Signal）：信号是<b>比较复杂的通信方式</b>，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了 支持Unix早期信号语义函数<b>sigal</b>外，还支持语义符合Posix.1标准的信号函数<b>sigaction</b>（实际上，该函数是基于BSD的，BSD为了 实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；</div><div><br/></div><div>3 报文（Message）队列（<b>消息队列</b>）：消息队列是消息的<b>链接表</b>，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列<b>克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</b></div><div>int msgget(key_t key,int flag);//将键变成标识符，一个唯一的ID。</div><div><br/></div><div><b>4 共享内存：</b>使得多个进程可以访问同一块内存空间，是<b>最快的可用IPC形式</b>。是<b>针对其他通信机制运行效率较低而设计的。</b>往往与其它通信机制，如信号量结合使用，来达到进程间的<b>同步访问</b>及互斥。</div><div><br/></div><div><br/></div><div><b>5 信号量</b>（semaphore）：主要作为<b>进程间</b>以及<b>同一进程不同线程之间</b>的同步手段。实际上是同步原语而不是IPC，常用于共享资源的同步访问。（创建信号量集、对信号量赋初值、。。。）</div><div><br/></div><div>（3、4、5）具有类似结构，《标识符，键》前者为内部名，后者为外部名，键由内核变换成标识符。</div><div><br/></div><div>6 <b>套接口</b>（Socket）：更为一般的进程间通信机制，<b>可用于不同机器之间的进程间通信</b>。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</div><div><br/></div><div>服务器进程是守护进程时，所有客户进程用某种形式的IPC与其联系：需要使用有名的IPC（FIFO、消息队列）</div><div><br/></div><div><b><font color="#FF0000">Nginx进程通信</font></b></div><div>1 共享内存</div><div>通过mmap()或者shmget()创建一块线性地址空间；</div><div>void* mmap(coid *start,size_t length,ing prot,int flags<strike>,int fd,off_t offset</strike>);</div><div>mmap可以将磁盘文件映射到内存，fd即为操作的磁盘文件，prot指操作方式。</div><div>通过munmap()或者shmdt()释放。</div><div><b>ngx_shm_alloc(ngx_shm_t *shm);ngx_shm_free（）：</b></div><div><b>封装mmap，且无映射文件；封装以/dev/zero文件进行映射的mmap；封装shmget。</b></div><div><b>Nginx一般由master进程创建共享内存，然后fork子进程，所有进程开始使用这块内存。是Nginx进程间共享数据的主要方式。</b></div><div>例子：统计整个服务器HTTP连接状况的功能。共享的统计变量，存放于共享内存中。</div><div><br/></div><div>2 套接字 ==》封装形成Nginx频道  <b><font color="#FF0000">Nginx进程间通信</font></b></div><div>ngx_channel_t结构封装要传递的命令、socketpair申请到的一个套接字。主要用于master进程向worker进程传递命令。</div><div>将套接字设置为无阻塞模式。</div><div><br/></div><div>3 信号</div><div><br/></div><div><br/></div><div><b><font color="#FF0000">进程同步</font></b></div><div>信号量</div><div><br/></div><div>记录锁</div><div><br/></div><div><b><font color="#FF0000">Nginx进程同步</font></b></div><div>1 原子操作</div><div><br/></div><div>2 信号量</div><div>Nginx仅把它作为简单的互斥锁使用，使用信号量作为互斥锁有可能导致进程睡眠。</div><div><br/></div><div>3 文件锁</div><div>基于文件的互斥锁。</div><div>int fcntl(int fd,in cmd,struct flock *lock);</div><div>根据fd文件描述符确定对谁操作，lock说明锁类型，锁区域起始，偏移量，哪个进程拥有这个锁。</div><div><br/></div><div><b>基于原子操作、信号量、文件锁封装了一个ngx_shmtx_t互斥锁。根据不同的配置选用不同的锁。</b></div><div>一般情况下<b>不直接利用信号量</b>，因为一旦获取信号量互斥锁失败，进程则睡眠，其它请求就会饿死。</div><div><br/></div><div><hr/></div><div><b><font color="#FF0000">事件处理模块、架构</font></b></div><div><br/></div><div><b>事件驱动架构：</b></div><div>由一些<b>事件发生源</b>产生事件，由一个或多个<b>事件收集器</b>来收集、分发事件，然后许多<b>事件处理器会注册自己感兴趣的事件</b>，同时”消费“这些事件。</div><div>事件发生源：网卡、磁盘、定时器。</div><div>事件收集器：事件模块。</div><div>事件处理器：所有模块。</div><div><br/></div><div>传统事件模型：每个事件消费者独占一个进程资源。</div><div><b>Nginx事件模型</b>：事件消费者只是被事件分发着进程短期调用而已。缺点：每个事件消费者不能有阻塞行为。</div><div>请求的<b>多阶段异步处理</b>：（获取静态文件的HTTP请求）（如何划分请求阶段：找到阻塞方法或者代码段）</div><div>（1）接收到SYN包==》建立TCP连接</div><div>（2）接收到TCP的ACK包==》开始接受用户请求</div><div>（3）接收到用户的数据包==》分析接收的请求是否完整</div><div>（4）接收到用户的数据报==》收到完整请求，开始处理用户请求</div><div>（5）收到已连接的TCP的ACK包==》读取部分静态文件内容发给用户</div><div>（6）收到最后数据的ACK包==》对于非keep-alive请求，主动关闭连接</div><div>（7）接收到FIN包==》用户结束连接</div><div><br/></div><div><b>多阶段异步处理 + 时间驱动框架</b> ：能够极大的提高网络性能，使得每个进程能够全力运转，不会或者尽量少的出现进程休眠状态。</div><div><br/></div><div>ngx_events_module模块：解析events配置项，并管理这些存储配置项的结构体。</div><div>ngx_event_core_module模块：连接池的创建、决定使用哪种事件驱动机制，初始化要用的事件模块。</div><div>ngx_connect_t：用于表示一个TCP连接，该结构体中包含读写事件ngx_event_t。</div><div>ngx_epoll_module模块:实现两个结构体ngx_module_t 和 ngx_event_module_t。</div><div><br/></div><div><hr/><b><font color="#FF0000">HTTP模块</font></b></div><div>1 所有的server虚拟主机以<b>散列表</b>组织起来。关键字为每个server name字符串；hash的值就是每个表示server结构的结构体地址ngx_http_core_srv_conf_t。使用开放寻址法处理冲突。</div><div>  所有的location表达式会以一个<b>静态的二叉查找树</b>组织起来。</div><div>2 HTTP框架目的：</div><div>事件框架对应传输层TCP；HTTP框架对应应用层，解决HTTP的网络传输、解析、组装；</div><div>HTTP框架为HTTP模块屏蔽事件驱动架构。</div><div><br/></div><div><br/></div><div><hr/></div><div><b><font color="#FF0000">负载均衡模块</font></b></div><div>1 区分worker进程间的负载均衡 和 后端服务器之间的负载均衡。</div><div>2 nginx还可以按照调度规则实现动态、静态页面的分离，可以按照轮询、ip哈希、URL哈希、权重等多种方式对后端服务器做负载均衡。如果只有一台服务器时,这个服务器挂了,那么对于网站来说是个灾难.因此，这时候的负载均衡就会大显身手了,它会自动剔除挂掉的服务器</div><div>3 nginx 的 upstream目前支持 4 种方式的分配 ：</div><p>1)轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 </p><p>2)weight ：指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 </p><p>3)ip_hash ：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。  </p><p>4)fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。  </p><p>5)url_hash（第三方）</p><p><span lang="EN-US">Nginx默认采用round_robin加权算法。</span></p><div><span style="color:#ff0000">加权轮询策略</span></div><div>优点：适用性更强，不依赖于客户端的任何信息，完全依靠后端服务器的情况来进行选择。能把客户端请求更合理更均匀地分配到各个后端服务器处理。</div><div>缺点：同一个客户端的多次请求可能会被分配到不同的后端服务器进行处理，<b>无法满足做会话保持的应用的需求</b>。</div><div><br/></div><div><span style="color:#ff0000">IP哈希策略</span></div><div>优点：能较好地把同一个客户端的多次请求分配到同一台服务器处理，避免了加权轮询无法适用会话保持的需求。</div><div>缺点：当某个时刻来自某个IP地址的请求特别多，那么将导致某台后端服务器的压力可能非常大，而其他后端服务器却空闲的不均衡情况、</div><div><br/></div><div><br/></div><div><hr/></div><div>Nginx与Apache性能比较</div><div><br/></div><div>nginx采用了异步非阻塞的方式来处理请求，也就是说，nginx是可以同时处理成千上万个请求的。想想apache的常用工作方式（apache也有 异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作 系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的cpu开销很大，自然性能就上不去了，而这些开销完全是没有意义的。</div><div><span style="color: rgb(37, 37, 37); line-height: 22.399999618530273px; background-color: rgb(255, 255, 255);">Nginx是一款面向性能设计的HTTP服务器，相较于</span><a href="http://zh.wikipedia.org/wiki/Apache_HTTP_Server" style="text-decoration: none; color: rgb(11, 0, 128); line-height: 22.399999618530273px; background-image: none; background-color: rgb(255, 255, 255);" title="Apache HTTP Server">Apache</a><span style="color: rgb(37, 37, 37); line-height: 22.399999618530273px; background-color: rgb(255, 255, 255);">、</span><a href="http://zh.wikipedia.org/wiki/Lighttpd" style="text-decoration: none; color: rgb(11, 0, 128); line-height: 22.399999618530273px; background-image: none; background-color: rgb(255, 255, 255);" title="Lighttpd">lighttpd</a><span style="color: rgb(37, 37, 37); line-height: 22.399999618530273px; background-color: rgb(255, 255, 255);">具有占有</span><a href="http://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98" style="text-decoration: none; color: rgb(11, 0, 128); line-height: 22.399999618530273px; background-image: none; background-color: rgb(255, 255, 255);" title="内存">内存</a><span style="color: rgb(37, 37, 37); line-height: 22.399999618530273px; background-color: rgb(255, 255, 255);">少，稳定性高等优势。</span></div><div><br/></div><div><h2 style="margin: 0px; padding: 0px;"><font size="3">apache三种工作模式</font></h2><div><br/></div><div>Apache有三种工作模块，分别为prefork、worker、event。</div><div><span style="line-height: 22.68000030517578px;">prefork：多进程，每个请求用一个进程响应，这个过程会用到<b>select机制</b>来通知。</span></div><div><span style="line-height: 22.68000030517578px;">worker：多线程，一个进程可以生成多个线程，每个线程响应一个请求，但<b>通知机制还是select</b>不过可以接受更多的请求。</span></div><div><span style="line-height: 22.68000030517578px;">event：基于异步I/O模型，一个进程或线程，每个进程或线程响应多个用户请求，它是基于事件驱动（也就是epoll机制）实现的。</span></div></div><div><br/></div><div> 对于那些需要更强大的Web应用服务器（比如大小、可定制、响应速度、可扩展性等方面）的人而言，Apache明显不符合他们的要求 </div><div><a href="http://blog.csdn.net/jackem/article/details/2871958">http://blog.csdn.net/jackem/article/details/2871958</a> Apache的最新更新  <b>增加了 event MPM模型</b></div><div><br/></div><div><span style="line-height: 22.68000030517578px; background-color: rgb(246, 246, 246);">如何提高Web服务器的并发连接处理能力</span><p style="margin: 0px; padding: 0px; line-height: 22.68000030517578px;">有几个基本条件：</p><ul style="margin: 0px; padding: 0px; line-height: 22.68000030517578px;"><li style="margin: 0px; padding: 0px;">基于线程，即一个进程生成多个线程，每个线程响应用户的每个请求。</li><li style="margin: 0px; padding: 0px;">基于事件的模型，一个进程处理多个请求，并且通过epoll机制来通知用户请求完成。</li><li style="margin: 0px; padding: 0px;">基于磁盘的AIO（异步I/O）</li><li style="margin: 0px; padding: 0px;">支持mmap内存映射，mmap传统的web服务器，进行页面输入时，都是将磁盘的页面先输入到内核缓存中，再由内核缓存中复制一份到web服务器上，mmap机制就是让内核缓存与磁盘进行映射，web服务器，直接复制页面内容即可。不需要先把磁盘的上的页面先输入到内核缓存去。</li></ul></div><div><br/></div><div><h2 style="box-sizing: border-box; font-weight: 500; line-height: 2; color: rgb(51, 51, 51); margin-top: 20px; margin-bottom: 10px; background-color: rgb(250, 250, 246);"><font size="3">Apache和Nginx比较</font></h2><h3 style="box-sizing: border-box; font-weight: 500; line-height: 2; color: rgb(51, 51, 51); margin-top: 20px; margin-bottom: 10px; background-color: rgb(250, 250, 246);"><font size="3">功能对比</font></h3><p style="box-sizing: border-box; margin: 0px 0px 10px; color: rgb(51, 51, 51); line-height: 32.400001525878906px; background-color: rgb(250, 250, 246);">Nginx和Apache一样，都是HTTP服务器软件，在功能实现上都采用模块化结构设计，都支持通用的语言接口，如PHP、Perl、Python等，同时还支持正向和反向代理、虚拟主机、URL重写、压缩传输、SSL加密传输等。</p><ol style="box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); line-height: 32.400001525878906px; background-color: rgb(250, 250, 246);"><li style="box-sizing: border-box;">在功能实现上，Apache的所有模块都支持动、静态编译，而Nginx模块都是静态编译的，</li><li style="box-sizing: border-box;">对FastCGI的支持，Apache对Fcgi的支持不好，而Nginx对Fcgi的支持非常好；</li><li style="box-sizing: border-box;">在处理连接方式上，Nginx支持epoll，而Apache却不支持；</li><li style="box-sizing: border-box;">在空间使用上，Nginx安装包仅仅只有几百K，和Nginx比起来Apache绝对是庞然大物。</li></ol><h3 style="box-sizing: border-box; font-weight: 500; line-height: 2; color: rgb(51, 51, 51); margin-top: 20px; margin-bottom: 10px; background-color: rgb(250, 250, 246);"><font size="3">Nginx相对apache的优点</font></h3><ul style="box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); line-height: 32.400001525878906px; background-color: rgb(250, 250, 246);"><li style="box-sizing: border-box;">轻量级，同样起web 服务，比apache 占用<b>更少的内存及资源</b></li><li style="box-sizing: border-box;">静态处理，Nginx <b>静态处理性能</b>比 Apache 高 <b>3倍</b>以上</li><li style="box-sizing: border-box;">抗并发，nginx 处理请求是<b>异步非阻塞的</b>，而apache则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能。在Apache+PHP（prefork）模式下，如果PHP处理慢或者前端压力很大的情况下，很容易出现Apache进程数飙升，从而拒绝服务的现象。</li><li style="box-sizing: border-box;"><b>高度模块化的设计</b>，编写模块相对简单</li><li style="box-sizing: border-box;">社区活跃，各种高性能模块出品迅速啊</li></ul><h3 style="box-sizing: border-box; font-weight: 500; line-height: 2; color: rgb(51, 51, 51); margin-top: 20px; margin-bottom: 10px; background-color: rgb(250, 250, 246);"><font size="3">apache相对nginx的优点</font></h3><ul style="box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); line-height: 32.400001525878906px; background-color: rgb(250, 250, 246);"><li style="box-sizing: border-box;">rewrite，比nginx 的rewrite 强大</li><li style="box-sizing: border-box;"><b>模块超多</b>，基本想到的都可以找到</li><li style="box-sizing: border-box;"><b>少bug</b>，nginx的bug相对较多</li><li style="box-sizing: border-box;"><b>超稳定</b></li><li style="box-sizing: border-box;">Apache对PHP支持比较简单，Nginx需要配合其他后端用</li></ul><h3 style="box-sizing: border-box; font-weight: 500; line-height: 2; color: rgb(51, 51, 51); margin-top: 20px; margin-bottom: 10px; background-color: rgb(250, 250, 246);"><font size="3">选择Nginx的优势所在</font></h3><ol style="box-sizing: border-box; margin-top: 0px; margin-bottom: 10px; color: rgb(51, 51, 51); line-height: 32.400001525878906px; background-color: rgb(250, 250, 246);"><li style="box-sizing: border-box;">作为Web服务器: <b>Nginx处理静态文件</b>、索引文件，自动索引的效率非常高。 那是因为静态文件本身也是磁盘IO操作</li><li style="box-sizing: border-box;">作为代理服务器，Nginx可以实现<b>无缓存</b>的反向代理加速，提高网站运行速度。</li><li style="box-sizing: border-box;">作为<b>负载均衡服务器</b>，Nginx既可以在内部直接支持Rails和PHP，也可以支持HTTP代理服务器对外进行服务，同时还支持简单的容错和利用算法进行负载均衡。</li><li style="box-sizing: border-box;">在性能方面，Nginx是专门为性能优化而开发的，在实现上非常注重效率。它采用内核Poll模型(epoll and kqueue )，可以支持更多的并发连接，最大可以支持对50 000个并发连接数的响应，而且只占用很低的内存资源。</li><li style="box-sizing: border-box;">在稳定性方面，Nginx采取了<b>分阶段资源分配技术</b>，使得CPU与内存的占用率非常低。Nginx官方表示，Nginx保持10 000个没有活动的连接，而这些连接只占用2.5MB内存，因此，类似DOS这样的攻击对Nginx来说基本上是没有任何作用的。</li><li style="box-sizing: border-box;">在高可用性方面，Nginx支持热部署，启动速度特别迅速，因此可以在<b>不间断服务</b>的情况下，对软件版本或者配置进行升级，即使运行数月也无需重新启动，几乎可以做到7×24小时不间断地运行。</li></ol><h2 style="box-sizing: border-box; font-weight: 500; line-height: 2; color: rgb(51, 51, 51); margin-top: 20px; margin-bottom: 10px; background-color: rgb(250, 250, 246);"><font size="3">同时使用Nginx和Apache</font></h2><p style="box-sizing: border-box; margin: 0px 0px 10px; color: rgb(51, 51, 51); line-height: 32.400001525878906px; background-color: rgb(250, 250, 246);">由于Nginx和Apache各自的优势，现在很多人选择了让两者在服务器中共存。在服务器端让Nginx在前，Apache在后。由Nginx做负载均衡和反向代理，并且处理静态文件，讲动态请求（如PHP应用）交给Apache去处理。</p></div><div><br/></div><div><br/></div><div><a href="http://yansu.org/2014/02/15/apache-and-nginx.html">http://yansu.org/2014/02/15/apache-and-nginx.html</a> Nginx与Apache 分析的挺好</div><div><a href="http://www.juziku.com/wiki/15028.htm">http://www.juziku.com/wiki/15028.htm</a></div><div><a href="http://zyan.cc/nginx_php_v6/">http://zyan.cc/nginx_php_v6/</a> </div><div><hr/>
首先就聊了下Nginx，什么进程模型，优点等等。然后问了select、poll和epoll的区别。</div><div>Nginx的优越性在哪？我就提提进程模型、epoll了，再和Apache简单做了下比较。</div><div><span style="font-family:微软雅黑"><br/></span></div><div><span style="font-family:微软雅黑"><br/></span></div><div><font face="微软雅黑"><br/></font></div><div><span style="font-family:微软雅黑"><br/></span></div><div><span style="font-family:微软雅黑"><br/></span></div></div>
</div></body></html> 