<html>
<head>
  <title>网络面试--整理</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="3331"/>
<h1>网络面试--整理</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><font size="3"><strong><font face="宋体">⑤</font></strong><font face="宋体">会话层（</font>Session layer<font face="宋体">）</font><br/><font face="宋体">维持不同应用程序的<b>数据保持隔离</b></font>[<font face="宋体">会话控制</font>]<br/><font face="宋体">会话层建立、管理和终止表示层与实体之间的通信会话。通信会话包括发生在不同网络应用层之间的服务请求和服务应答，这些请求与应答通过会话层的协议实现。它还包括创建检查点，使通信发生中断的时候可以返回到以前的一个状态。</font><br/><strong><font face="宋体">⑥</font></strong><font face="宋体">表示层（</font>Presentation layer<font face="宋体">）</font><br/><font face="宋体">为应用层提供数据，并<b>负责数据的转换及代码的格式化</b></font> [<font face="宋体">表示数据；对数据加密、压缩和转换服务等</font>]<br/><font face="宋体">表示层提供多种功能用于应用层数据编码和转化，以确保以一个系统应用层发送的信息可以被另一个系统应用层识别。表示层的编码和转化模式包括公用数据表示格式、性能转化表示格式、公用数据压缩模式和公用数据加密模式。</font></font></div><div><font size="3"><font face="宋体"><br/></font></font></div><div>1. 电路交换与分组交换的区别？优劣对比。<br style="word-wrap: break-word;"/>
2. OSI有哪几层，会画出来，知道主要几层的各自作用。<br style="word-wrap: break-word;"/>
3. TCP/IP有哪几层，会画出来，知道所有层数的作用，会列举各层主要的协议名称。<br style="word-wrap: break-word;"/>
4. 硬件(MAC)地址的概念及作用。<br style="word-wrap: break-word;"/>
5. ARP协议的用途 及算法、在哪一层上会使用arp ？<br style="word-wrap: break-word;"/><div>6. CRC冗余校验算法，反码和检验算法。<br style="word-wrap: break-word;"/>
7. 如何实现透明传输。</div>
8. 知道各个层使用的是哪个数据交换设备。（交换机、路由器、网关）<br style="word-wrap: break-word;"/>
9. 路由表的内容。<br style="word-wrap: break-word;"/>
10. 分组转发算法。<br style="word-wrap: break-word;"/>
11. IP报文的格式，格式的各个字段的含义要理解。<br style="word-wrap: break-word;"/>
12.MTU的概念，啥叫路径MTU？ MTU发现机制，TraceRoute(了解)。<br style="word-wrap: break-word;"/><b>13.RIP协议的概念及算法。</b><br style="word-wrap: break-word;"/>
14.ICMP协议的主要功能。<br style="word-wrap: break-word;"/>
15.组播和广播的概念，IGMP的用途。(环回地址、广播地址)<br style="word-wrap: break-word;"/>
16.Ping协议的实现原理，ping 命令格式。<br style="word-wrap: break-word;"/>
17. 子网划分的概念，子网掩码。<br style="word-wrap: break-word;"/>
18. IP地址的分类，如何划分的，及会计算各类地址支持的主机数。<br style="word-wrap: break-word;"/>
19.DNS的概念，用途，DNS查询的实现算法。<br style="word-wrap: break-word;"/>
20. TCP与UDP的概念，相互的区别及优劣。<br style="word-wrap: break-word;"/>
21.UDP报文的格式，字段的意义。<br style="word-wrap: break-word;"/>
22. TCP 报文的格式，字段的意义。<br style="word-wrap: break-word;"/>
23.TCP通过哪些措施，保证传输可靠？<br style="word-wrap: break-word;"/>
24. 三次握手，四次断开过程。<br style="word-wrap: break-word;"/>
25. TIME_WAIT状态的概念及意义。<br style="word-wrap: break-word;"/>
26.滑动窗口协议 与停止等待协议的区别。<br style="word-wrap: break-word;"/>
27. TCP的流量控制和拥塞控制实现原理(会画拥塞控制的典型图)。<br style="word-wrap: break-word;"/>
28.TCP的快速重传与快速恢复算法。<br style="word-wrap: break-word;"/>
29.TFTP 与 FTP的区别。<br style="word-wrap: break-word;"/>
30.阻塞方式和非阻塞方式，阻塞connect与非阻塞connect。(比较难，有兴趣可以了解)<br style="word-wrap: break-word;"/>
31. HTTP基本格式。（java程序员必须掌握）</div><div><br/></div><div>1 tcp连接<span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">建立连接：三次握手</span></div><div><a href="http://images.cnitblog.com/blog/385532/201308/30193701-72f027c0ea0f4c69834076466fa5383c.png" shape="rect" style="background-color: rgb(255, 255, 255); line-height: 24px; margin: 0px; padding: 0px; color: rgb(90, 90, 90);" target="_blank"><img src="网络面试--整理_files/Image.png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></a></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">关闭连接：四次挥手</span></div><div><a href="http://images.cnitblog.com/blog/385532/201308/30193703-63640062b79a4fc8b8ed31e95fd87bd8.png" shape="rect" style="background-color: rgb(255, 255, 255); line-height: 24px; margin: 0px; padding: 0px; color: rgb(90, 90, 90);" target="_blank"><img src="网络面试--整理_files/Image [1].png" type="image/png" alt="image" border="0" height="298" style="cursor: default;cursor: default;cursor: default;" width="426"/></a></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;"><b>三次握手建立连接时，发送方再次发送确认的必要性？</b></span></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">主要是为了防止已失效的连接请求报文段突然又传到了B,因而产生错误。假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络结点长时间滞留了，一直延迟到连接释放以后的某个时间才到达B，本来这是一个早已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了，这样一直等待A发来数据，B的许多资源就这样白白浪费了。</span></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;"><b>四次挥手释放连接时，等待2MSL的意义？</b></span></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">第一，为了保证A发送的最有一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN和ACK报文段的确认。B会超时重传这个FIN和ACK报文段，而A就能在2MSL时间内收到这个重传的ACK+FIN报文段。接着A重传一次确认。</span></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">第二，就是防止上面提到的已失效的连接请求报文段出现在本连接中，A在发送完最有一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。</span></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;"><br/></span></div><div style="margin-bottom: 20px;"><div style="line-height: 20px;"><div style="color: rgb(75, 75, 75);">2 电路交换与分组交换的区别？优劣对比。<br clear="none"/></div><div><pre xml:space="preserve"><font face="宋体"><font color="#4B4B4B">（1）电路交换：由于电路交换在通信之前要在</font><b style="color: rgb(75, 75, 75);">通信双方之间建立一条被双方独占的物理通路</b><font color="#4B4B4B">（由通信双方之间的交换设备和链路逐段连接而成），因而有以下优缺点。 <br clear="none"/>优点： <br clear="none"/>①</font><b style="color: rgb(75, 75, 75);">时延非常小</b><font color="#4B4B4B">、</font><b style="color: rgb(75, 75, 75);">实时性强</b><font color="#4B4B4B">、</font><b style="color: rgb(75, 75, 75);">不存在失序问题、</b><font color="#4B4B4B">电路交换既适用于传输模拟信号，也适用于传输数字信号、交换设备（交换机等）及控制均较简单。 <br clear="none"/>缺点： <br clear="none"/>①</font><b><font color="#FF0000">平均</font></b><font color="#4B4B4B">连接</font><b style="color: rgb(75, 75, 75);">建立时间对计算机通信来说嫌长、</b><font color="#4B4B4B">物理通路被通信</font><b style="color: rgb(75, 75, 75);">双方独占</b><font color="#4B4B4B">，信道利用低、不同规格的终端很难相互进行通信及差错控制。 </font></font></pre><pre xml:space="preserve"><font face="宋体"><font color="#4B4B4B"><br clear="none"/>（2）报文交换：报文交换是</font><b style="color: rgb(75, 75, 75);">以报文为数据交换的单位</b><font color="#4B4B4B">，报文<b>携带有目标地址、源地址</b>等信息，在交换结点采用<b>存储转发</b>的传输方式，因而有以下优缺点： <br clear="none"/>优点： <br clear="none"/>①报文交换</font><b style="color: rgb(75, 75, 75);">不需要为通信双方预先建立一条专用的通信线路</b><font color="#4B4B4B">，不存在连接建立时延，用户可随时发送报文、采用存储转发的传输方式、不独占</font><b style="color: rgb(75, 75, 75);">大大提高了通信线路的利用率。 </b><font color="#4B4B4B"><br clear="none"/>缺点： <br clear="none"/>①</font><b><font color="#FF0000">转发时延</font></b><font color="#4B4B4B">（包括接收报文、检验正确性、排队、发送时间等），不适合传送实时或交互式业务的数据、数字信号、<b>报文长度没有限制</b>，要求网络中每个结点有较大的缓冲区。</font></font></pre><pre xml:space="preserve"><font face="宋体"><font color="#4B4B4B"><br clear="none"/>（3）分组交换：分组交换仍采用存储转发传输方式，但</font><b style="color: rgb(75, 75, 75);">将一个长报文先分割为</b><b><font color="#FF0000">若干个较短的分组</font></b><b style="color: rgb(75, 75, 75);">，然后把这些分组（携带源、目的地址和编号信息）逐个地发送出去</b><font color="#4B4B4B"><br clear="none"/>优点： <br clear="none"/>①</font><b style="color: rgb(75, 75, 75);">加速了数据在网络中的传输。</b><font color="#4B4B4B">因为分组是逐个传输，可以使后一个分组的存储操作</font><b><font color="#4B4B4B">与前一个分组的转发操作</font><font color="#FF0000">并行</font></b><font color="#4B4B4B">，这种流水线式传输方式</font><b style="color: rgb(75, 75, 75);">减少了报文的</b><b style="color: rgb(75, 75, 75);">传输时间</b><font color="#4B4B4B">。</font><font color="#4B4B4B"><br clear="none"/>②</font><b style="color: rgb(75, 75, 75);">简化了存储管理</b><font color="#4B4B4B">。因为分组的长度固定，</font><b><font color="#4B4B4B">相应的缓冲区的大小也</font><font color="#FF0000">固定</font></b><font color="#4B4B4B">，在交换结点中存储器的管理通常被简化为对缓冲区的管理，相对比较容易。 <br clear="none"/>③</font><b style="color: rgb(75, 75, 75);">减少了出错机率和</b><b><font color="#FF0000">重发</font></b><b style="color: rgb(75, 75, 75);">数据量。</b><font color="#4B4B4B">因为分组较短，其出错机率必然减少，每次重发的数据量也就大大减少，这样不仅提高了可靠性，也减少了传输时延。 <br clear="none"/>④由于分组短小，更适用于采用优先级策略，便于及时传送一些紧急数据，因此对于计算机之间的突发式的数据通信，分组交换显然更为合适些。 <br clear="none"/>缺点： <br clear="none"/>①仍存在存储转发时延 <br clear="none"/>②每个分组都要加上源、目的地址和分组编号等信息，使传送的信息量大约<b>增大5%～10%</b>，一定程度上降低了通信效率，增加了处理的时间，使控制复杂，时延增加。 <br clear="none"/>③当分组交换采用数据报服务时，可能出现失序、丢失或重复分组，分组到达目的结点时，要对分组按编号进行排序等工作，增加了麻烦。<br clear="none"/>总之，</font><b style="color: rgb(75, 75, 75);">若要传送的数据量很大，且其传送时间远大于呼叫时间，则采用电路交换较为合适；当端到端的通路有很多段的链路组成时，采用分组交换传送数据较为合适。从提高整个网络的信道利用率上看，报文交换和分组交换优于电路交换，其中分组交换比报文交换的时延小，尤其适合于计算机之间的突发式的数据通信。</b><font color="#4B4B4B"><br clear="none"/><br clear="none"/>3 以太网帧的大小 64--1500的确定<br clear="none"/></font><a href="http://nxcsl.blog.163.com/blog/static/26456360200731762012503/" shape="rect" style="color: rgb(75, 75, 75);" target="_blank">http://nxcsl.blog.163.com/blog/static/26456360200731762012503/</a><font color="#4B4B4B"><br clear="none"/>碰撞产生时，先发送数据的那端还没有将数据发完，则会接收到碰撞信号，此时这端将会重传该<br clear="none"/>帧。如果已经发送结束则不会重传。若要A端检测碰撞的发生，则A B之间的距离很重要。<br clear="none"/></font><span style="color: rgb(75, 75, 75);">IEEE定义了这个标准，一个碰撞域内，最远的两台机器之间的round-trip time 要小于512bit time.<br clear="none"/>(来回时间小于512位时，所谓位时就是传输一个比特需要的时间）</span><font color="#4B4B4B"><br clear="none"/>最大值MTU：为交互使用提供足够快的响应时间。<br clear="none"/></font></font></pre></div></div><div style="color: rgb(75, 75, 75); line-height: 20px;">4<span style="color: rgb(0, 0, 0); line-height: normal;"> ping 192.168.178.103的具体过成 见</span><a href="http://techbbs.zol.com.cn/1/61_4740.html" shape="rect" style="line-height: normal;" target="_blank">http://techbbs.zol.com.cn/1/61_4740.html</a><span style="color: rgb(0, 0, 0); line-height: normal;"> </span></div><div><div style="color: rgb(0, 0, 0); line-height: normal;">ping 192.168.178.103与ping <a href="http://www.baidu.com的区别/" shape="rect" target="_blank">www.baidu.com的区别</a><br clear="none"/></div><div style="color: rgb(0, 0, 0); line-height: normal;">是什么原因引起单方面ping通呢</div><blockquote style="margin: 0px 0px 0px 40px; border: none; padding: 0px;"><div style="color: rgb(0, 0, 0); line-height: normal;"><span style="color: rgb(51, 51, 51); line-height: 22px; background-color: rgb(255, 255, 255);">“网络适配器”、“拨号网络适配器”、“拨号适配器”、“物理网络适配器”、“逻辑网络适配器”这些说法，看起来使人一头雾水，容易使人搞混淆。</span></div><div style="color: rgb(0, 0, 0); line-height: normal;"><br clear="none" style="color: rgb(51, 51, 51); line-height: 22px; background-color: rgb(255, 255, 255);"/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><span style="color: rgb(51, 51, 51); line-height: 22px; background-color: rgb(255, 255, 255);">■“网络适配器”、“物理网络适配器”，一般就是俗称的网卡，是硬件。</span></div><div style="color: rgb(0, 0, 0); line-height: normal;"><br clear="none" style="color: rgb(51, 51, 51); line-height: 22px; background-color: rgb(255, 255, 255);"/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><span style="color: rgb(51, 51, 51); line-height: 22px; background-color: rgb(255, 255, 255);">■“拨号网络适配器”、“拨号适配器””、“逻辑网络适配器”，在人们口语中，有两种意思：有时可以理解为对“网络适配器”设置的一组参数，有时又指拨号软件：拨号网络适配器是PPP拨号网络系统的虚拟拨号适配器，普通拨号MODEM必须通过它才能和ISP取得联系，现在的宽带必须使用PPPOE虚拟拨号适配器才能和宽带ISP取得联系。</span></div></blockquote><div style="color: rgb(0, 0, 0); line-height: normal;"><br clear="none"/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><a href="http://www.cnblogs.com/panxueji/archive/2013/05/12/3073924.html" shape="rect" target="_blank">http://www.cnblogs.com/panxueji/archive/2013/05/12/3073924.html 在浏览器内输入url后发生的事情</a></div><div style="color: rgb(0, 0, 0); line-height: normal;"><a href="http://zhumeng8337797.blog.163.com/blog/static/10076891420110694312990/" shape="rect" target="_blank">http://zhumeng8337797.blog.163.com/blog/static/10076891420110694312990/ </a>  DNS递归迭代区别</div></div><div style="color: rgb(0, 0, 0); line-height: normal;"><br/></div><div style="color: rgb(0, 0, 0); line-height: normal;">5I/O模式</div><div><p style="text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px;"><span style="color: rgb(51, 51, 51); margin: 0px; padding: 0px; line-height: 21px;"><strong><span style="color: rgb(51, 51, 255);">同步：</span></strong></span><span style="color: rgb(51, 51, 51); margin: 0px; padding: 0px; line-height: 21px;"><br style="margin: 0px; padding: 0px;"/></span><span style="color: rgb(0, 0, 0); margin: 0px; padding: 0px; line-height: 21px;"><span style="color: rgb(51, 51, 51);">所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。</span><span style="text-indent: 32px; line-height: 24px;"><font color="#666666">也就是</font><b><font color="#FF0000">必须一件一件事做</font></b></span><span style="color: rgb(102, 102, 102); line-height: 18px; text-indent: 32px;"><span lang="EN-US" style="line-height: 24px;">,</span><span style="line-height: 24px;">等前一件做完了才能做下一件事。</span></span></span></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px; line-height: 18px;"></p><p align="left" style="line-height: 26px; background-color: rgb(255, 255, 255); color: rgb(102, 102, 102);">例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 <b>这个期间客户端浏览器不能干任何事</b></p><p style="color: rgb(0, 0, 0); text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px; line-height: 18px;"><span style="color: rgb(51, 51, 51); margin: 0px; padding: 0px; line-height: 21px;"><strong><span style="color: rgb(51, 51, 255);">异步：</span></strong></span><span style="color: rgb(51, 51, 51); margin: 0px; padding: 0px; line-height: 21px;"><br style="margin: 0px; padding: 0px;"/>
    </span><span style="margin: 0px; padding: 0px; line-height: 21px;"><font color="#333333">异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。</font><b><font color="#FF0000">实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</font></b></span></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px; line-height: 18px;"><span style="font-family: verdana, &amp;amp;amp;apos;ms song&amp;amp;amp;apos;, 宋体, Arial, 微软雅黑, Helvetica, sans-serif; margin: 0px; padding: 0px; line-height: 21px;">     <span style="color: rgb(102, 102, 102); line-height: 24px; text-indent: 32px;">例如 ajax请求（</span><span style="color: rgb(102, 102, 102); text-indent: 32px; line-height: 24px;">异步）</span><span lang="EN-US" style="color: rgb(102, 102, 102); text-indent: 32px; line-height: 24px;">: </span><span style="color: rgb(102, 102, 102); text-indent: 32px; line-height: 24px;">请求通过事件触发</span><span lang="EN-US" style="color: rgb(102, 102, 102); text-indent: 32px; line-height: 24px;">-&gt;</span><span style="color: rgb(102, 102, 102); text-indent: 32px; line-height: 24px;">服务器处理（<b>这是浏览器仍然可以作其他事情</b>）</span><span lang="EN-US" style="color: rgb(102, 102, 102); text-indent: 32px; line-height: 24px;">-&gt;</span><span style="color: rgb(102, 102, 102); text-indent: 32px; line-height: 24px;">处理完毕</span></span></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px; line-height: 18px;"><span style="margin: 0px; padding: 0px; line-height: 21px;"><span style="color: rgb(51, 51, 255);"><strong>阻塞</strong></span></span><span style="margin: 0px; padding: 0px; line-height: 21px;"><br style="margin: 0px; padding: 0px;"/>
     </span><span style="margin: 0px; padding: 0px; line-height: 21px;">阻塞调用是指调用结果返回之前，<b>当前线程会被挂起</b>。函数只有在得到结果之后才会返回。</span></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px; line-height: 18px;"><span style="margin: 0px; padding: 0px; line-height: 21px;">   有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。<b>对于同</b></span><span style="margin: 0px; padding: 0px; line-height: 21px;"><b>步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已</b>。</span><span style="margin: 0px; padding: 0px; line-height: 21px;"> 例如，我们在s</span><span style="margin: 0px; padding: 0px;"><span style="margin: 0px; padding: 0px; line-height: 21px;">ocket</span></span><span style="margin: 0px; padding: 0px; line-height: 21px;">中调用r</span><span style="margin: 0px; padding: 0px; line-height: 21px;">ecv</span><span style="margin: 0px; padding: 0px; line-height: 21px;">函数，如果缓冲区中没有数</span><span style="margin: 0px; padding: 0px; line-height: 21px;">据，这个函数就会一直等待，直到有数据才返回。而此时，当前线程还会继续处理各种各样的消息。</span></p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px;"><span style="margin: 0px; padding: 0px; line-height: 21px;"><span style="color: rgb(51, 51, 255);"><strong>非阻塞</strong></span></span><span style="margin: 0px; padding: 0px; line-height: 21px;"><br style="margin: 0px; padding: 0px;"/>
      </span><span style="margin: 0px; padding: 0px; line-height: 21px;">非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，<b>该函数不会阻塞当前线程，而会立刻返回</b>。</span><span style="margin: 0px; padding: 0px; line-height: 21px;"><br style="margin: 0px; padding: 0px;"/></span><span style="margin: 0px; padding: 0px; line-height: 21px;">对象的阻塞模式和阻塞函数调用</span><span style="margin: 0px; padding: 0px; line-height: 21px;"><br style="margin: 0px; padding: 0px;"/></span><span style="margin: 0px; padding: 0px; line-height: 21px;">对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但是并不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过一定的</span><span style="margin: 0px; padding: 0px; line-height: 18px;"><span style="margin: 0px; padding: 0px; line-height: 21px;">API</span></span><span style="margin: 0px; padding: 0px; line-height: 21px;">去轮询状</span><span style="line-height: 18px;"> </span><span style="margin: 0px; padding: 0px; line-height: 21px;">态，在适当的时候调用阻塞函数，就可以避免阻塞。而对于非阻塞对象，调用特殊的函数也可以进入阻塞调用。函数</span><span style="margin: 0px; padding: 0px; line-height: 18px;"><span style="margin: 0px; padding: 0px; line-height: 21px;">select</span></span><span style="margin: 0px; padding: 0px; line-height: 21px;">就是这样的一个例子。</span></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px; line-height: 18px;"> </p><div><span style="line-height: 20px;"><b><span style="line-height: 21px;">1. 同步，就是我调用一个功能，该功能没有结束前，我死等结果。</span><br style="line-height: 21px;"/><span style="line-height: 21px;">2. 异步，就是<span style="line-height: 20px;">我调用一个功能，</span>不需要知道该功能结果，该功能有结果后通知我（回调通知）</span><br style="line-height: 21px;"/><span style="line-height: 21px;">3. 阻塞，      就是调用我（函数），我<span style="line-height: 20px;">（函数）</span>没有接收完数据或者没有得到结果之前，我不会返回。</span><br style="line-height: 21px;"/><span style="line-height: 21px;">4. 非阻塞，  就是调用我<span style="line-height: 20px;">（函数）</span>，我<span style="line-height: 20px;">（函数）</span>立即返回，<span style="line-height: 20px;">通过select通知调用者</span></span></b></span></div></div><div><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">同步IO和异步IO的区别就在于：<span style="color: rgb(255, 0, 0);">应用程序的调用是否立即返回！</span></p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><span style="color: rgb(0, 0, 0);">阻塞IO和非阻塞IO的区别就在于：</span><span style="color: rgb(255, 0, 0);">数据拷贝的时候进程是否阻塞！</span></p></div><div><span style="color: rgb(51, 102, 153); line-height: 36px;">I/O模型</span></div><div><p style="color: rgb(51, 51, 51); text-align: left; padding-top: 0px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 15px; line-height: 24px;">1)阻塞I/O（blocking I/O）<br/>
2)非阻塞I/O （nonblocking I/O）<br/>
3) I/O复用(select 和poll) （I/O multiplexing）<br/>
4)信号驱动I/O （signal driven I/O (SIGIO)）<br/>
5)异步I/O （asynchronous I/O (the POSIX aio_functions)）<br/></p><p style="color: rgb(51, 51, 51); text-align: left; padding-top: 0px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 15px; line-height: 24px;"></p><p style="color: rgb(51, 51, 51); line-height: 21px; text-align: left;"><b>前四种都是同步，只有最后一种才是异步IO。</b></p></div><div><h3 style="color: rgb(51, 51, 51); line-height: 21px; text-align: left; margin: 0px; padding: 0px;"><span style="color: rgb(51, 51, 255); line-height: 24px;"><strong><font size="3">阻塞I/O模型：</font></strong></span></h3><p style="color: rgb(51, 51, 51); line-height: 21px; text-align: left;">        <span style="background-color: rgb(255, 204, 0);">简介：进程会</span><span style="color: rgb(255, 0, 0); background-color: rgb(255, 204, 0);">一直阻塞</span><span style="background-color: rgb(255, 204, 0);">，直到数据拷贝完成</span><br/></p><p style="color: rgb(51, 51, 51); text-align: left; padding-top: 0px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 15px; line-height: 24px;"><span style="line-height: 22px;">     应用程序调用一个IO函数，导致应用程序阻塞，等待数据准备好。 如果数据没有准备好，一直等待….数据准备好了，从内核拷贝到用户空间,IO函数返回成功指示。</span></p><p style="color: rgb(51, 51, 51); text-align: left; padding-top: 0px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 15px; line-height: 24px;"><strong><span style="color: rgb(255, 102, 0);">阻塞I/O模型图：</span></strong>在调用recv()/recvfrom（）函数时，发生在内核中等待数据和复制数据的过程。</p></div><div>优点：<b style="color: rgb(51, 51, 51); line-height: 21px; text-align: left;">开发网络程序比较简单，容易实现</b><span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 21px; text-align: left;">。当希望能够立即发送和接收数据，且处理的套接字数量比较少的情况下。</span></div><div>缺点：<span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 21px; text-align: left;">当希望同时处理大量套接字时，将无从下手，其扩展性很差</span></div><div><h3 style="color: rgb(51, 51, 51); line-height: 21px; text-align: left; margin: 0px; padding: 0px;"><font size="3"><span style="color: rgb(51, 51, 255); line-height: 24px;"><strong>非阻塞IO模型</strong></span> </font></h3></div><div style="color: rgb(0, 0, 0); line-height: normal;"><div>优点：<span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 26px; text-align: left;">非阻塞套接字在控制建立的多个连接，在数据的收发量不均，时间不定时，明显具有优势。</span></div><div>缺点：<span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 26px; text-align: left;">在这个不断测试的过程中，会大量的占用CPU的时间。</span><span style="background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); line-height: 26px; text-align: left;">使用非阻塞模式套接字，需要编写更多的代码，以便在每个Windows Sockets API函数调用中，对收到的WSAEWOULDBLOCK错误进行处理。因此，非阻塞套接字便显得有些难于使用。</span></div></div><div style="color: rgb(0, 0, 0); line-height: normal;"><div><h3 style="margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><strong><span style="color: rgb(51, 51, 255);"><font size="3">IO复用模型：</font></span></strong></h3></div></div><div style="color: rgb(0, 0, 0); line-height: normal;"><div><span style="color: rgb(51, 51, 51); line-height: 24px; text-align: left; background-color: rgb(255, 255, 255);"> I/O复用模型会用到<b>select、poll、epoll函数</b>，这几个函数<b>也会使进程阻塞</b>，但是和阻塞I/O所不同的的，这两个函数可以<b>同时阻塞多个I/O操作</b>。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数</span><span style="line-height: 24px; text-align: left; color: rgb(51, 51, 255);">。</span></div></div><div style="line-height: normal; color: rgb(0, 0, 0);"><br/></div><div><div style="text-align: left;"><font color="#333333"><span style="line-height: 21px;"><br/></span></font></div><h3 style="margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><span style="color: rgb(51, 51, 255);"><strong><font size="3">信号驱动IO</font></strong></span></h3><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); padding-top: 0px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 15px; line-height: 24px;"><span style="color: rgb(51, 51, 255);">    <span style="background-color: rgb(255, 204, 0);">简介：两次调用，两次返回；</span><br/></span></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); padding-top: 0px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 15px; line-height: 24px;"><span style="color: rgb(51, 51, 255);">    </span>首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。</p><h3 style="margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><font size="3"><a name="t6" style="color: rgb(51, 102, 153);"></a><strong><span style="color: rgb(51, 51, 255);">异步IO模型</span></strong></font></h3><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">       <span style="background-color: rgb(255, 204, 0);">  简介：数据拷贝的时候进程无需阻塞。</span><br/></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); padding-top: 0px; padding-bottom: 0px; margin-top: 0px; margin-bottom: 15px; line-height: 24px;"><span style="color: rgb(51, 51, 255);"><strong>     </strong></span>当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者的输入输出操作</p></div><div style="line-height: normal; color: rgb(0, 0, 0);"><div><h3 style="margin: 0px; padding: 0px; color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><span style="line-height: 20px;"><span style="line-height: 21px;"><span style="color: rgb(51, 51, 255);"><strong><font size="3">5个I/O模型的比较：</font></strong></span></span></span></h3><div><br/></div><div><span style="line-height: 20px;"><span style="line-height: 21px;"><img src="http://my.csdn.net/uploads/201204/12/1334216724_2405.jpg" style="cursor: default;cursor: default;cursor: default;"></img></span></span></div></div></div><div style="line-height: normal; color: rgb(0, 0, 0);"><span style="line-height: 20px;"><span style="line-height: 21px;">6 </span></span>I/O复用 </div><div style="line-height: normal;"><p style="color: rgb(0, 0, 0); margin-top: 0px; margin-bottom: 10px; padding-top: 0px; padding-bottom: 6px; border-bottom-color: rgb(222, 223, 225); border-bottom-width: 1px; border-bottom-style: solid; clear: both;"><span style="color: rgb(51, 102, 153);"><span style="line-height: 36px;">select、poll、epoll简介<br/></span></span></p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现</p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255); margin: 5px auto; padding-top: 0px; padding-bottom: 0px;"></p><p style="color: rgb(51, 51, 51); text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;"><strong><span style="line-height: 20px;"><span style="line-height: 21px;">select（数组）：</span></span></strong></p><p style="text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;"><font color="#333333">select本质上是通过</font><b><font color="#FF0000">设置或者检查存放fd标志位的数据结构</font></b><font color="#333333">来进行下一步处理。这样所带来的缺点是：</font></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;">1、 单个进程可监视的<b>fd数量被限制</b>，即能监听端口的大小有限。<br/></p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">      一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.</p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">2、 对socket进行扫描时是<b>线性扫描</b>，即采用轮询的方法，效率较低：<br/></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;">       当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。</p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;">3、<b>需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</b></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;"><strong><span style="line-height: 20px;"><span style="line-height: 21px;">poll（链表）：</span></span></strong></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;">poll本质上和select没有区别，它将<b>用户传入的数组</b>拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。</p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;">它没有最大连接数的限制，原因是它是<b>基于链表来存储的</b>，但是同样有一个缺点：</p><div>1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                                                                                                                                      </div><div>2、poll还有一个特点是“<b>水平触发</b>”，如果报告了fd后，没有被处理，那么<b>下次poll时会再次报告该fd</b>。</div><div><br/></div><strong style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><span style="line-height: 20px;"><span style="line-height: 21px;">epoll（红黑树）:</span></span></strong><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;">epoll支持<b>水平触发和边缘触发</b>，最大的特点在于<b>边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次</b>。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知<br/></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;"><span style="color: rgb(0, 0, 0); background-color: rgb(255, 204, 0);">epoll的优点：</span><br/></p><p style="color: rgb(51, 51, 51); text-align: left; background-color: rgb(255, 255, 255); line-height: 1.8; margin: 12px auto;"></p><div style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><strong><span style="color: rgb(51, 51, 255);">1、没有最大并发连接的限制，</span></strong>能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；<br/><span style="color: rgb(51, 51, 255);"><strong>2、效率提升</strong></span>，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；<br/>
     <span style="background-color: rgb(255, 204, 0);"> 即Epoll最大的优点就在于它<b>只管你“活跃”的连接</b>，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</span><br/></div><div style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><strong style="color: rgb(51, 51, 51);"><span style="color: rgb(51, 51, 255);">3、 内存拷贝</span></strong><font color="#333333">，利用</font><b style="color: rgb(51, 51, 51);">mmap()文件映射内存加速与内核空间的消息传递</b><font color="#333333">；即epoll使用mmap减少复制开销。只拷贝一次</font><br/><p style="margin: 10px auto; color: rgb(0, 0, 0); line-height: 18px; text-align: start;"> <span lang="EN-US" style="line-height: 18.399999618530273px;">l<span style="line-height: normal;">  </span></span><span style="line-height: 18.399999618530273px;">此外，内核使用了</span><span lang="EN-US" style="line-height: 18.399999618530273px;">slab</span><span style="line-height: 18.399999618530273px;">机制，为</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll</span><span style="line-height: 18.399999618530273px;">提供了快速的数据结构：</span></p><p style="margin: 10px auto 10px 21pt; text-indent: 0cm; color: rgb(0, 0, 0); text-align: start; line-height: 13.800000190734863px;"><span style="line-height: 18.399999618530273px;">在内核里，一切皆文件。所以，</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll</span><span style="line-height: 18.399999618530273px;">向内核注册了一个文件系统，用于存储上述的被监控的</span><span lang="EN-US" style="line-height: 18.399999618530273px;">fd</span><span style="line-height: 18.399999618530273px;">。当你调用</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll_create</span><span style="line-height: 18.399999618530273px;">时，就会在这个虚拟的</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll</span><span style="line-height: 18.399999618530273px;">文件系统里创建一个</span><span lang="EN-US" style="line-height: 18.399999618530273px;">file</span><span style="line-height: 18.399999618530273px;">结点。当然这个</span><span lang="EN-US" style="line-height: 18.399999618530273px;">file</span><span style="line-height: 18.399999618530273px;">不是普通文件，它只服务于</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll</span><span style="line-height: 18.399999618530273px;">。</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll</span><span style="line-height: 18.399999618530273px;">在被内核初始化时（操作系统启动），同时会开辟出</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll</span><b><span style="line-height: 18.399999618530273px;">自己的内核高速</span><span lang="EN-US" style="line-height: 18.399999618530273px;">cache</span></b><span style="line-height: 18.399999618530273px;"><b>区</b>，用于安置每一个我们想监控的</span><span lang="EN-US" style="line-height: 18.399999618530273px;">fd</span><span style="line-height: 18.399999618530273px;">，这些</span><span lang="EN-US" style="line-height: 18.399999618530273px;">fd</span><span style="line-height: 18.399999618530273px;">会以红黑树的形式保存在内核</span><span lang="EN-US" style="line-height: 18.399999618530273px;">cache</span><span style="line-height: 18.399999618530273px;">里，以支持快速的查找、插入、删除。这个内核高速</span><span lang="EN-US" style="line-height: 18.399999618530273px;">cache</span><span style="line-height: 18.399999618530273px;">区，就是建立连续的物理内存页，然后在之上建立</span><span lang="EN-US" style="line-height: 18.399999618530273px;">slab</span><span style="line-height: 18.399999618530273px;">层，简单的说，就是物理上分配好你想要的</span><span lang="EN-US" style="line-height: 18.399999618530273px;">size</span><span style="line-height: 18.399999618530273px;">的内存对象，每次使用时都是使用空闲的已分配好的对象。</span> </p><div><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">l<span style="line-height: normal;">  </span></span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">的第三个优势在于：当我们调用</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_ctl</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">往里塞入百万个</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">时，</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_wait</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">仍然可以飞快的返回，并有效的将发生事件的</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">给我们用户。这是由于我们在调用</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_create</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">时，内核除了帮我们在</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">文件系统里建了个</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">file</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">结点，在内核</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">cache</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">里建了个红黑树用于存储以后</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_ctl</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">传来的</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="line-height: 18.399999618530273px;"><font color="#333333">外，还会再</font><b><font color="#FF0000">建立一个</font></b></span><span lang="EN-US" style="line-height: 18.399999618530273px;"><b><font color="#FF0000">list</font></b></span><span style="line-height: 18.399999618530273px;"><b><font color="#FF0000">链表，用于存储准备就绪的事件，</font></b><font color="#333333">当</font></span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_wait</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">调用时，仅仅观察这个</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">list</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">链表里有没有数据即可。有数据就返回，没有数据就</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">sleep</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">，等到</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">timeout</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">时间到后即使链表没数据也返回。所以，</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_wait</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">非常高效。而且，通常情况下即使我们要监控百万计的</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">，大多一次也只返回很少量的准备就绪</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">而已，所以，</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_wait</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">仅需要从内核态</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">copy</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">少量的</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">到用户态而已。那么，这个准备就绪</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">list</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">链表是怎么维护的呢？当我们执行</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">epoll_ctl</span><span style="line-height: 18.399999618530273px;"><font color="#333333">时，</font><b><font color="#FF0000">除了把</font></b></span><b><font color="#FF0000"><span lang="EN-US" style="line-height: 18.399999618530273px;">fd</span><span style="line-height: 18.399999618530273px;">放到</span><span lang="EN-US" style="line-height: 18.399999618530273px;">epoll</span><span style="line-height: 18.399999618530273px;">文件系统里</span><span lang="EN-US" style="line-height: 18.399999618530273px;">file</span></font></b><span style="line-height: 18.399999618530273px;"><b><font color="#FF0000">对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数</font><font color="#333333">，</font></b><font color="#333333">告诉内核，如果这个</font></span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">的中断到了，就把它放到准备就绪</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">list</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">链表里。所以，当一个</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">（例如</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">socket</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">）上有数据到了，内核在把设备（例如网卡）上的数据</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">copy</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">到内核中后就来把</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">fd</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">（</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">socket</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">）插入到准备就绪</span><span lang="EN-US" style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">list</span><span style="color: rgb(51, 51, 51); line-height: 18.399999618530273px;">链表里了。</span></div><div style="color: rgb(51, 51, 51);"><span style="line-height: 18.399999618530273px;"><br/></span></div><div style="color: rgb(51, 51, 51);"><br/></div><strong style="color: rgb(51, 51, 51);">select、poll、epoll 区别总结：</strong><br/></div><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;">1、支持一个进程所能打开的最大连接数</p><table border="1" cellpadding="0" cellspacing="0" style="color: rgb(51, 51, 51); text-align: left; border: 1px solid rgb(192, 192, 192); line-height: 25px; background-color: rgb(255, 255, 255); border-collapse: collapse;"><tbody><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">select</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是32*32，同理64位机器上FD_SETSIZE为32*64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响，这需要进一步的测试。</p></td></tr><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">poll</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</p></td></tr><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">epoll</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接</p></td></tr></tbody></table><p style="color: rgb(51, 51, 51); text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;">2、FD剧增后带来的IO效率问题</p><table border="1" cellpadding="0" cellspacing="0" style="color: rgb(51, 51, 51); text-align: left; border: 1px solid rgb(192, 192, 192); line-height: 25px; background-color: rgb(255, 255, 255); border-collapse: collapse;"><tbody><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">select</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。</p></td></tr><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">poll</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">同上</p></td></tr><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">epoll</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。</p></td></tr></tbody></table><p style="color: rgb(51, 51, 51); text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;">3、 消息传递方式</p><table border="1" cellpadding="0" cellspacing="0" style="color: rgb(51, 51, 51); text-align: left; border: 1px solid rgb(192, 192, 192); line-height: 25px; background-color: rgb(255, 255, 255); border-collapse: collapse;"><tbody><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">select</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">内核需要将消息传递到用户空间，都需要内核拷贝动作</p></td></tr><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">poll</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">同上</p></td></tr><tr><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="111"><p style="line-height: 1.8; margin: 12px auto;">epoll</p></td><td style="border: 1px solid rgb(192, 192, 192); padding: 3px; border-collapse: collapse;" width="457"><p style="line-height: 1.8; margin: 12px auto;">epoll通过内核和用户空间共享一块内存来实现的。</p></td></tr></tbody></table><p style="color: rgb(51, 51, 51); text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;"><strong><span style="color: rgb(255, 0, 0);">总结：</span></strong><br/></p><p style="color: rgb(51, 51, 51); text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;">综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p><p style="color: rgb(51, 51, 51); text-align: left; line-height: 25px; background-color: rgb(255, 255, 255); margin: 12px auto;">1、表面上看epoll的性能最好，但是<b>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</b></p><div>2、<span style="color: rgb(0, 0, 0); background-color: rgb(255, 204, 0);">select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善</span></div></div><div style="line-height: normal;"><hr/></div><div style="line-height: normal;"><b><font color="#FF0000">7 UNPv3上一共总结了9种服务器模型分别是：</font></b></div><div><b><font color="#FF0000">1.迭代服务器 </font></b></div><div><b><font color="#FF0000">2.并发服务器，为每个客户fork一个进程  </font></b></div><div><b><font color="#FF0000">3.预先派生子进程，每个子进程都调用accept，accept无上锁保护 </font></b></div><div><b><font color="#FF0000">4.预先派生子进程，以文件锁的方式保护accept   </font></b></div><div><b><font color="#FF0000">5.预先派生子进程，以线程互斥锁上锁的方式保护accept </font></b></div><div><b><font color="#FF0000">6.预先派生子进程，由父进程向子进程传递套接口描述字  </font></b></div><div><b><font color="#FF0000">7.并发服务器，为每个客户请求创建一个线程 </font></b></div><div><b><font color="#FF0000">8.预先创建线程，以互斥锁上锁方式保护accept  </font></b></div><div><b><font color="#FF0000">9.预先创建线程，由主线程调用accept，并把每个客户连接传递给线程池中某个可用线程</font></b></div><p><b>1.迭代服务器</b></p><div>典型代码：</div><div>socket</div><div>bind</div><div>listen</div><div>for(;;)</div><div>{</div><div>    connfd = accept(listenfd, (SA*)&amp;cliaddr, &amp;clilen);</div><div>    process_connection(connfd);</div><div>    close(connfd);</div><div>}</div><div><b>优点：主要是编程简单，无进程控制开销。如时间获取程序。</b></div><div><b>缺点：处理完一个连接之后才能处理下一个连接，无并发可言，应用很少</b></div><div><br/></div><div><b>2.并发服务器，为每个客户fork一个进程</b></div><div>典型代码：</div><div>init_address(server_addr)</div><div>listenfd = socket(AF_INET,SOCKET_STREAM,0);</div><div>bind(listenfd, (SA*)server_addr, sizeof(serveraddr));</div><div>listen(listenfd,BACKLOG);</div><div>for(;;)</div><div>{</div><div>    connfd = accept(listenfd, (SA*)&amp;cliaddr, &amp;clilen);</div><div>    if(connfd &lt; 0)</div><div>    {</div><div>        if(EINTR == errno)</div><div>            continue;</div><div>         else</div><div>             //error</div><div>    }</div><div><br/></div><div>    <b>if((childpid = fork()) == 0)</b></div><div>    {</div><div>        close(c=listenfd);</div><div>        process_connection(connfd); //child process </div><div>        exit(0);</div><div>    }</div><div>    close(connfd);//parent, close connected socket</div><div>}</div><div>早期的网络服务器每天处理几百或者几千个客户连接时，这种服务器模型还是可以应付的。</div><div>但是随着互联网业务的迅猛发展，繁忙的web服务器每天可能需要处理千万以上的连接，并发服务器的问题在于为每个客户<b>现场fork一个子进程比较消耗cpu时间。</b></div><div><br/></div><div><b>进程池：父进程持续监视可用子进程数</b></div><div><b><br/></b></div><div>3.预先派生子进程，每个子进程都调用accept，<b>accept无上锁保护,大家都是同一个listenfd</b></div><div>缺点：1.服务器必须在启动的时候判断需要预先派生多少子进程</div><div>      2.<b>惊群现象</b>(一个连接到来唤醒所有监听进程)，不过较新版本的linux貌似修正了这个问题</div><div>优点：无须引入父进程执行fork的开销就能处理新到的客户</div><div><br/></div><div>4.预先派生子进程，以<b><font color="#FF0000">文件锁（使用fcntl()函数实现</font>）</b>的方式保护accept</div><div>本模型与3的区别仅仅是对accept(listenfd)使用了文件锁.</div><div>这种模型是为了解决以<b>库函数（accept不是一个原子操作）</b>的形式实现的<b>accept不能在多个进程中引用同一个监听套接口的</b><b>问题</b>(源自BSD的unix，在内核中实现的accept可以引用)。使用文件锁保证了每个连接到来，只有一个进程阻塞在accept调用上。对于已经在内核中实现了accept的系统来说，这种模型至少增加了加锁解锁的开销，所以相对于第3种模型性能较低(特别是在消除了惊群问题的系统上)</div><div><br/></div><div><span style="color:#ff0000">5.预先派生子进程，以<b>线程互斥锁</b>上锁的方式保护accept</span></div><div>典型代码：</div><div>static pthread_mutex_t *mptr;</div><div>void </div><div>my_lock_init(char *pathname)</div><div>{</div><div>    int   fd;</div><div>    pthread_mutexattr_t mattr;</div><div>   </div><div>    //因为是相关进程所以可以使用/dev/zero设备创建共享内存</div><div>    //优势是调用mmap创建共享存储区之前无需一个实际的文件</div><div>    //映射/dev/zero自动创建一个指定长度的映射区</div><div>    fd = open(&quot;/dev/zero&quot;, O_RDWR, 0,);</div><div>    // 将mptr映射到共享存储区</div><div>    mptr = mmap(0, sizeof(pthread_mutex_t), PORT_READ | PORT_WRITE, MAP_SHARED, fd, 0);</div><div>    close(fd);</div><div>    <b>pthread_mutexattr_init(&amp;mattr);</b></div><div><b>    pthread_mutexattr_setpshared(&amp;mptr, PTHREAD_PROCESS_SHARED);</b></div><div><b>    pthread_mutex_init(mptr, &amp;mattr);</b></div><div>}</div><div><br/></div><div>void </div><div>my_lock_wait()</div><div>{</div><div>    pthread_mutex_lock(mptr);</div><div>}</div><div><br/></div><div>void</div><div>my_lock_release()</div><div>{</div><div>    pthread_mutex_unlock(mptr);</div><div>}</div><div><br/></div><div>int</div><div>main(int argc, char **argv)</div><div>{</div><div>   //init socket and address</div><div>    my_lock_init(pathname);</div><div>    for(i = 0; i &lt; nchildren; ++i)</div><div>    {</div><div>        pids[i] = child_make(i, listenfd, addrlen);</div><div>    }</div><div><br/></div><div>    for(;;)</div><div>        pause();</div><div>}</div><div><br/></div><div>pid_t</div><div>child_make(int i, int listenfd, int addrlen)</div><div>{</div><div>    pid_t pid;</div><div><br/></div><div>    if((pid = fork) &gt; 0)</div><div>        return pid;</div><div><br/></div><div>    child_main(i, listenfd, addrlen);</div><div>}</div><div><br/></div><div>void </div><div>child_main()</div><div>{</div><div>    for(;;)</div><div>    {</div><div>        my_lock_wait();</div><div>        connfd = accept(listenfd, chiladdr, &amp;clilen);</div><div>        my_lock_release();</div><div>        web_child(connfd);</div><div>        close(connfd);</div><div>    }</div><div>}</div><div> </div><div>这种模型在模型4上做出了进一步的改进，<b>由于以文件锁的方式实现保护会涉及文件系统，这样</b><b>可能比较耗时</b>，所以<b>改进的办法是以pthread mutex互斥量代替文件锁。</b>使用线程上锁保护accept不仅适用于同一进程内各线程上锁，也适用于不同进程间上锁在多进程环境下使用线程互斥锁实现同步有两点要求：</div><div>1.<b>互斥锁必须放在由所有进程共享的内存区</b></div><div>2.必须<b>告知线程库</b>这是在<b>不同的进程间共享的互斥锁</b></div><div>注意：<b><font color="#FF0000">目前很火的高性能web服务器的代表nginx就是采用的这种模型</font></b>，网络上对nginx的研究很多。</div><div><br/></div><div><font color="#FF0000"><b>6.预先派生子进程，由父进程向子进程传递套接口描述字</b></font></div><div>优势：不需要对accept上锁保护</div><div>劣势：1.编码复杂—父进程必须<b>跟踪子进程的忙闲状态</b>，以便给空闲子进程传递新的套接口。在前述的预先派生子进程的例子中，父进程无需关心由哪一个子进程接收一个客户连接，操作系统会根据调度算法处理这些细节。采用这种模型的结果是这些进程<b>无法均衡的处理连接</b>。</div><div>      2.父进程通过<b>字节流管道把描述子传递到各个子进程</b>，并且各个子进程通过字节流管道写回单个字节，比起无论是使用共享内存区中的互斥锁还是使用文件锁实施的上锁和解锁都更费时。</div><div><br/></div><div><span style="color:#ff0000">7.并发服务器，为每个客户请求创建一个线程</span></div><div>典型代码：</div><div>for(;;)</div><div>{</div><div>    connfd = accept(listenfd, cliaddr, &amp;clilen,);</div><div>    pthread_create(&amp;tid, NULL, &amp;doit, (void *)connfd);</div><div>}</div><div><br/></div><div>void *</div><div>doit(void *arg)</div><div>{</div><div>    pthread_detach(pthread_self());</div><div>    web_child((int)arg);</div><div>    close((int)arg)</div><div>    return (NULL);</div><div>}</div><div><div>优点：编码简单</div><div>缺点：现场为每个连接创建线程相对于预先派生线程池来说比较耗时</div><br/></div><div><span style="color:#ff0000">8.预先创建线程，以互斥锁上锁方式保护accept</span></div><div>优势 1.编程简介，易于理解</div><div>     2.线程池的方式避免了现场创建线程的开销</div><div>     3.OS<b>线程调度算法保证了线程负载的均衡性</b></div><div>这就是leader-follower模式一个线程等待连接到来，其他线程休眠；新连接到来后leader去处理连接，释放listenfd,其他线程竞抢监听套接口listenfd(可能有惊群的问题)。leader在处理完连接以后成为follower</div><div><br/></div><div>9.预先创建线程，由主线程调用accept，并把每个客户连接传递给线程池中某个</div><div>  可用线程</div><div> 劣势：相对于模型8，该模型不仅需要使用pthread mutex额外还需要使用pthread cond</div><div style="color: rgb(0, 0, 0); line-height: normal;"><br/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><hr/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><div><span style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255);">常见的应用中有哪些是应用TCP协议的，哪些又是应用UDP协议的，为什么它们被如此设计？</span></div><div><span style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255);">以下一般或必须用udp实现？</span></div><div><span style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255);">1 </span><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;"><b>多播</b>的信息一定要用udp实现，因为tcp只支持一对一通信。</span></div><div><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">2 </span><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">如果一个应用场景中大多是<b>简短的信息</b>，适合用udp实现，因为udp是基于报文段的，它直接对上层应用的数据封装成报文段，然后丢在网络中，如果信息量太大，会在链路层中被分片，影响传输效率。</span></div></div><div style="color: rgb(0, 0, 0); line-height: normal;">3 <span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">如果要求<b>快速响应</b>，那么udp听起来比较合适.</span><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">又想可靠传输，那么只能考上层应用自己制定规则了。</span></div><div style="color: rgb(0, 0, 0); line-height: normal;">4 <span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">ICQ,QQ的聊天模块。</span></div><div style="color: rgb(0, 0, 0); line-height: normal;"><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;"><b>QQ相关：</b></span></div><div style="color: rgb(0, 0, 0); line-height: normal;"><span style="background-color: rgb(255, 255, 255); color: rgb(64, 50, 38); line-height: 24px;">登陆采用TCP协议和HTTP协议，你和好友之间发送消息，主要采用UDP协议，内网传文件采用了P2P技术。</span></div><div><span style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255);">1.登陆过程，客户端client 采用TCP协议向服务器server发送信息，HTTP协议下载信息。登陆之后，会<b>有一个TCP连接来保持在线状态</b>。 </span><br style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255); margin: 0px; padding: 0px;"/><span style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255);">2.和好友发消息，客户端client采用UDP协议，但是需要通过服务器转发。腾讯为了确保传输消息的可靠，采用上层协议来保证可靠传输。<b>如果消息发送失败，客户端会提示消息发送失败，并可重新发送</b>。 </span><br style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255); margin: 0px; padding: 0px;"/><span style="color: rgb(64, 50, 38); line-height: 24px; background-color: rgb(255, 255, 255);">3.如果是在<b>内网</b>里面的两个客户端传文件，QQ采用的是<b>P2P技术</b>，不需要服务器中转。p2p技术：</span>依赖网络中参与者的计算能力和<a href="http://baike.baidu.com/view/10821.htm" target="_blank">带宽</a>，而不是把依赖都聚集在较少的几台服务器上。</div><div style="color: rgb(0, 0, 0); line-height: normal;"><img src="网络面试--整理_files/Image [2].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><br/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><br/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><b>HTTP协议？？？？</b></div><div style="color: rgb(0, 0, 0); line-height: normal;"><a href="http://www.360doc.com/content/10/0930/17/3668821_57590979.shtml#" style="background-color: rgb(255, 255, 255); line-height: 24px; margin: 0px; padding: 0px; color: rgb(90, 90, 90);">http协议比较通俗的解释</a></div><div style="color: rgb(0, 0, 0); line-height: normal;"><a href="http://blog.csdn.net/gueter/article/details/1524447" style="background-color: rgb(255, 255, 255); line-height: 24px; margin: 0px; padding: 0px; color: rgb(90, 90, 90);">http协议的具体细节</a></div><div style="color: rgb(0, 0, 0); line-height: normal;"><div>万维网知识：</div><div>1 怎样标志分布在因特网上的万维网文档？</div><div>URL：给资源的位置提供了一个抽象的识别方法。《<b>协议://主机:端口/路径</b>》 </div><div>HTTP形式的URL：默认端口为80，</div><div>2 用什么样的协议来实现万维网上的各种链接？</div><div><br/></div><div>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将<b><font color="#FF0000">超文本标记语言(HTML)文档</font></b>从Web服务器传送到客户端的浏览器</div><div><br/></div><div>HTTP协议：定义了浏览器怎样向web服务器请求万维网文档，服务器怎样把文档传送给浏览器，<b>相关的格式和规则</b>。面向事务的应用层协议。无连接、无状态。</div><div><br/></div><div><span style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">HTTP协议的主要特点可概括如下：</span><br style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"/><span style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">1.支持客户/服务器模式。</span><br style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"/><span style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</span><br style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"/><span style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</span><br style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"/><span style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</span><br style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"/><span style="line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</span></div><div><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);"><img src="网络面试--整理_files/Image [3].png" type="image/png" height="256" style="cursor: default;cursor: default;cursor: default;" width="583"/></p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">代理服务器就是网络信息的中转站，有什么功能呢？</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">1. 提高访问速度， 大多数的代理服务器都有缓存功能。</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">2. 突破限制， 也就是翻墙了</p><div>3. 隐藏身份。</div></div><div><br/></div><div><h1 style="font-family: &amp;amp;apos;black Verdana&amp;amp;apos;, Arial, Helvetica, sans-serif; background-color: rgb(165, 165, 165);"><font size="3">HTTP协议是无状态的<a name="statelesshttp"></a></font></h1><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">http协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对http服务器来说，它并不知道这两个请求来自同一个客户端。 为了解决这个问题， Web程序引入了<b><font color="#FF0000">Cookie机制来维护状态</font></b>.</p></div><div><h1 style="font-family: &amp;amp;apos;black Verdana&amp;amp;apos;, Arial, Helvetica, sans-serif; background-color: rgb(165, 165, 165);"><font size="3">HTTP消息的结构<a name="httpmeessagestructe"></a></font></h1><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">1 先看Request 消息的结构,   Request 消息分为3部分，第一部分叫Request line, 第二部分叫Request header, 第三部分是body. header和body之间有个空行， 结构如下图</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);"><img src="网络面试--整理_files/Image [4].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">第一行中的Method表示请求方法,比如&quot;POST&quot;,&quot;GET&quot;,  Path-to-resoure表示请求的资源， Http/version-number 表示HTTP协议的版本号</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">当使用的是&quot;GET&quot; 方法的时候， body是为空的</p></div><div>（1）request header</div><div><br/></div><div><br/></div><div><br/></div><div>2 <span style="background-color: rgb(255, 255, 255); line-height: 21px;">Response消息的结构, 和Request消息的结构基本一样。 同样也分为三部分,第一部分叫Response line, 第二部分叫Response header，第三部分是body. header和body之间也有个空行,  结构如下图</span></div><div><br/></div><div><img src="网络面试--整理_files/Image [5].png" type="image/png" style="cursor: default;cursor: default;cursor: default;"/></div><div><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">（1）Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);"><b>状态码</b>用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">1XX  <b>通知信息</b> - 表示请求已被成功接收，继续处理</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">2XX  <b>成功</b> - 表示请求已被成功接收，理解，接受  <b>200：成功</b>   <b>202：接受</b></p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">3XX  <b>重定向</b> - 要完成请求必须进行更进一步的处理  <b>301：永久性转移</b></p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">4XX  <b>客户端错误</b> -  请求有语法错误或请求无法实现  <b>400：错误请求  404：找不到</b></p><div>5XX  <b>服务器端错误</b> -   服务器未能实现<b>合法的请求</b></div></div><div><br/></div><div><h1 style="font-family: &amp;amp;apos;black Verdana&amp;amp;apos;, Arial, Helvetica, sans-serif; background-color: rgb(165, 165, 165);"><font size="3">Get和Post方法的区别<a name="getpost"></a></font></h1><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是GET,POST,PUT,DELETE. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。<span style="color: rgb(255, 0, 0);">GET一般用于获取/查询资源信息，而POST一般用于更新资源信息.</span></p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">我们看看GET和POST的区别</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">1. GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">3. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">4. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></div><div><br/></div><div><br/></div><div><h1 style="font-family: &amp;amp;apos;black Verdana&amp;amp;apos;, Arial, Helvetica, sans-serif; background-color: rgb(165, 165, 165);"><font size="3">HTTP协议是无状态的和Connection: keep-alive的区别<a name="statelessalive"></a></font></h1><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系</p><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);">HTTP是一个<span style="color: rgb(255, 0, 0);">无状态</span>的<span style="color: rgb(255, 0, 0);">面向连接</span>的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）</p><div style="word-wrap: break-word; line-height: 21px; background-color: rgb(255, 255, 255);">从HTTP/1.1起，默认都开启了Keep-Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</div><p style="margin: 10px auto; line-height: 21px; background-color: rgb(255, 255, 255);"> Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</p></div><div><a href="http://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html">http://www.cnblogs.com/TankXiao/archive/2012/02/13/2342672.html</a> </div><div><br/></div><div><a href="http://blog.csdn.net/gueter/article/details/1524447">http://blog.csdn.net/gueter/article/details/1524447</a> </div><div><br/></div></div><div style="color: rgb(0, 0, 0); line-height: normal;"><hr/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><b>传输层</b></div><div style="color: rgb(0, 0, 0); line-height: normal;"><img src="网络面试--整理_files/Image.jpg" type="image/jpeg" style="cursor: default;cursor: default;cursor: default;"/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><div><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><strong><span style="line-height: 21px;">传输层的功能</span></strong></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px;">        数据传送，不关心数据含义，进程间通信。</span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px;">        弥补高层（上3层）要求与网络层（基于下3层）数据传送服务质量间的差异（差错率、差错恢复能力、吞吐率、延时、费用等），对高层屏蔽网络层的服务的差异，提供稳定和一致的界面。</span></p></div></div><div style="color: rgb(0, 0, 0); line-height: normal;">端口号</div><div style="color: rgb(0, 0, 0); line-height: normal;"><img src="网络面试--整理_files/Image [1].jpg" type="image/jpeg" height="823" style="cursor: default;cursor: default;cursor: default;" width="752"/></div><div style="color: rgb(0, 0, 0); line-height: normal;"><div><p align="left" style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><strong><span style="line-height: 21px;">问题：什么是面向字节流、面向报文？</span></strong></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px;">       面向字节流：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是<b>一连串的无结构的字节流</b>。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。如果应用程序一次只发送一个<span style="color: rgb(0, 0, 0);">字节，TCP也可以等待积累有足够多的字节后再构成报文段发送出去。</span></span></p><div><span style="line-height: 21px; color: rgb(0, 0, 0);">    面向报文：面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。而且保留这些报文的边界。这也就是说，应用层交给UDP多长的报文，UDP就照样发送），即一次发送一个报文）。</span></div></div><div><strong style="line-height: 19px; text-align: -webkit-left;"><span style="line-height: 21px;">问题 ：UDP 如何发送大量的数据？如何处理分包？</span></strong></div><div><p align="left" style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">用 updclient 一次不能发送太大的数据量，不然就会报错：一个在数据报套接字上发送的消息大于内部消息缓冲器或其他一些网络限制，或该用户用于接收数据报的缓冲器比数据报小。但不知道一次到底能发多少字节？如果把一个大的字节数组拆分成若干个字节数组发送，那么接收时如何判断和处理呢？</span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);"> 答：方法很简单：</span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">1、在客户端将你要发送的内容（文件什么的都可以）分块，每块内容进行编号，然后发送；</span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">2、服务端在接收到你的分块数据以后，根据你的客户端数据内容的编号重新组装；</span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">3、一般我们在发送数据的时候，尽量采用比较小的数据块的方式（我的都没有超过1024的），数据块太大的话容易出现发送和接收的数据时间长，匹配出问题。</span></p></div></div><div style="color: rgb(0, 0, 0);"><div style="line-height: normal;"><p align="left" style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 19px; color: rgb(0, 0, 0);"><strong><span style="line-height: 21px;">问题 .有分片的情况下如下处理</span></strong></span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">        问：如果MTU是1500，使用UDP发送 2000，那么recvfrom(2000)是收到1500，还是2000?</span></p><div><span style="line-height: 21px; color: rgb(0, 0, 0);">        答：还是接收2000，数据分片由ip层处理了，放到udp还是一个完整的包。接收到的包是由路由路径上最少的MTU来分片，注意转到UDP已经在是组装好的(组装出错的包会经crc校验出错而丢弃)，是一个完整的数据包。</span></div></div><div style="line-height: normal;"><div><p align="left" style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 19px; color: rgb(0, 0, 0);"><strong><span style="line-height: 21px;">问题 .分片后的处理</span></strong></span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">       问：如果500那个片丢了怎么办？udp又没有重传</span></p><div><span style="line-height: 21px; color: rgb(0, 0, 0);">       答：<u>udp里有个crc检验，如果包不完整就会丢弃，也不会通知是否接收成功</u>，所以UDP是不可靠的传输协议，而且TCP不存在这个问题，有自己的重传机制。在内网来说，UDP基本不会有丢包，可靠性还是有保障。当然如果是要求有时序性和高可靠性，还是走TCP，不然就要自己提供重传和乱序处理( UDP内网发包处理量可以达 7M~10M/s )</span></div></div></div><div style="line-height: normal;"><div><strong style="line-height: 19px; text-align: -webkit-left;"><span style="line-height: 21px;">问题 .什么是TCP粘包</span></strong></div></div><div style="line-height: normal;"><div><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">   为了避免粘包现象，可采取以下几种措施。</span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">        一是对于发送方引起的粘包现象，用户可通过编程设置来避免，TCP提供了强制数据立即传送的操作指令push，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</span></p><p style="color: rgb(75, 75, 75); line-height: 20px; margin: 10px auto;"><span style="line-height: 21px; color: rgb(0, 0, 0);">        二是对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、提高接收进程优先级等措施，使其及时接收数据，从而尽量避免出现粘包现象；</span></p><div><span style="line-height: 21px; color: rgb(0, 0, 0);">         三是由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。</span></div></div></div><div style="line-height: normal;"><span style="line-height: 21px; color: rgb(0, 0, 0);"><br/></span></div><div><hr/><div><br/></div><div>tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支 持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</div></div><div><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html">http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html</a></div><div><br/></div><div>ifconfig:查看和配置网卡信息。</div><div><br/></div><div>Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。</div><div><a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html">http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html</a></div><div><br/></div><div><br/></div><div>ipconfig:是<a href="http://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BB%9F" title="微软">微软</a>的<a href="http://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1" title="操作系统">操作系统</a>的电脑上用来控制<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E8%84%91%E7%BD%91%E7%BB%9C" title="电脑网络">网络</a>连接的一个<a href="http://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E5%88%97" title="命令行">命令行</a>工具。它的主要功用，包括用来显示现时网络连接的设置（/all参数），或通过/release参数来释放取得的ip位置，和通过 /renew 来重新获取ip位置的分配。</div><div><br/></div></div></div></div>
</div></body></html> 