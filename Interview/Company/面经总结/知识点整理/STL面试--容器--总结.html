<html>
<head>
  <title>STL面试--容器--总结</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7601 Service Pack 1;"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="3407"/>
<h1>STL面试--容器--总结</h1>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><div><a href="http://blog.csdn.net/etwdone/article/details/8717467" shape="rect" target="_blank">http://blog.csdn.net/etwdone/article/details/8717467</a><br clear="none"/></div><div><a href="http://blog.csdn.net/etwdone/article/details/8717480" shape="rect" target="_blank">http://blog.csdn.net/etwdone/article/details/8717480</a></div><div><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.399999618530273px; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">3.STL map<span style="font-family: 宋体;">和</span><span style="font-family: &apos;Times New Roman&apos;;">set</span><span style="font-family: 宋体;">的使用虽不复杂，但也有一些不易理解的地方，如：</span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><div>（<span style="font-family: &apos;Times New Roman&apos;;">1</span><span style="font-family: 宋体;">）为何</span><span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">和</span><span style="font-family: &apos;Times New Roman&apos;;">set</span><span style="font-family: 宋体;">的插入删除效率比用其他序列容器高？，树</span></div><div><span style="font-family: 宋体;">插入：树结构索引查找更快。</span></div><div><span style="font-family: 宋体;">删除：不需要移动元素。</span></div><div><br/></div><div>（<span style="font-family: &apos;Times New Roman&apos;;">2</span><span style="font-family: 宋体;">）为何每次</span><span style="font-family: &apos;Times New Roman&apos;;">insert</span><span style="font-family: 宋体;">之后，以前保存的</span><span style="font-family: &apos;Times New Roman&apos;;">iterator</span><span style="font-family: 宋体;">不会失效？</span></div><div><span style="font-family: &apos;Times New Roman&apos;;">1、iterator</span><span style="font-family: 宋体;">这里就相当于<b>指向节点的指针，内存没有变，指向内存的指针怎么会失效呢</b></span><span style="font-family: &apos;Times New Roman&apos;;">(</span><span style="font-family: 宋体;">当然被删除的那个元素本身已经失效了</span><span style="font-family: &apos;Times New Roman&apos;;">)</span><span style="font-family: 宋体;">。</span></div><div><span style="font-family: 宋体;">2、相对于</span><span style="font-family: &apos;Times New Roman&apos;;">vector</span><span style="font-family: 宋体;">来说，每一次删除和插入，指针都有可能失效，调用</span><span style="font-family: &apos;Times New Roman&apos;;"><b>push_back（也会造成迭代器失效）</b></span><span style="font-family: 宋体;">在尾部插入也是如此。</span><span style="font-family: 宋体;">牢记这个原则：不要使用过期的</span><span style="font-family: &apos;Times New Roman&apos;;">iterator</span><span style="font-family: 宋体;">。</span></div><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">（<span style="font-family: &apos;Times New Roman&apos;;">3</span><span style="font-family: 宋体;">）为何</span><span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">和</span><span style="font-family: &apos;Times New Roman&apos;;">set</span><span style="font-family: 宋体;">不能像</span><span style="font-family: &apos;Times New Roman&apos;;">vector</span><span style="font-family: 宋体;">一样有个</span><span style="font-family: &apos;Times New Roman&apos;;">reserve</span><span style="font-family: 宋体;">函数来预分配数据？</span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">答：引起它的原因在于在<span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">和</span><span style="font-family: &apos;Times New Roman&apos;;">set</span><span style="font-family: 宋体;">内部存储的已经不是元素本身了，而是<b>包含元素的节点</b>。也就是说</span>map内部使用的<span style="font-family: &apos;Times New Roman&apos;;">Alloc</span><span style="font-family: 宋体;">并不是</span><span style="font-family: &apos;Times New Roman&apos;;">map</span>&lt;Key, Data, Compare, Alloc&gt;声明的时候从参数中传入的<span style="font-family: &apos;Times New Roman&apos;;">Alloc</span><span style="font-family: 宋体;">。对于vector我们知道它下一个元素存储的位置，但是map和set我们无法预知。</span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">7..1 hash_map<span style="font-family: 宋体;">和</span><span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">的区别在哪里？ </span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">构造函数。<span style="font-family: &apos;Times New Roman&apos;;">hash_map</span><span style="font-family: 宋体;">需要</span><span style="font-family: &apos;Times New Roman&apos;;">hash</span><span style="font-family: 宋体;">函数，等于函数；</span><span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">只需要比较函数</span><span style="font-family: &apos;Times New Roman&apos;;">(</span><span style="font-family: 宋体;">小于函数</span><span style="font-family: &apos;Times New Roman&apos;;">). </span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">存储结构。<span style="font-family: &apos;Times New Roman&apos;;">hash_map</span><span style="font-family: 宋体;">采用</span><span style="font-family: &apos;Times New Roman&apos;;">hash</span><span style="font-family: 宋体;">表存储，</span><span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">一般采用</span><a href="http://stl.winterxy.com/html/000039.html" style="color: rgb(51, 102, 153); text-decoration: none;"><span style="color: rgb(0, 0, 255);">红黑树<span style="font-family: &apos;Times New Roman&apos;;">(RB Tree)</span></span></a>实现。因此其<span style="font-family: &apos;Times New Roman&apos;;">memory</span><span style="font-family: 宋体;">数据结构是不一样的。 </span></p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><a name="4.2_什么时候需要用hash_map，什么" style="color: rgb(51, 102, 153);"></a>7.2 <span style="font-family: 宋体;">什么时候需要用</span><span style="font-family: &apos;Times New Roman&apos;;">hash_map</span><span style="font-family: 宋体;">，什么时候需要用</span><span style="font-family: &apos;Times New Roman&apos;;">map? </span></p><div>1、总体来说，<span style="font-family: &apos;Times New Roman&apos;;">hash_map </span><span style="font-family: 宋体;">查找速度会比</span><span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">快，而且查找速度基本和数据数据量大小，属于常数级别</span><span style="font-family: &apos;Times New Roman&apos;;">;</span><span style="font-family: 宋体;">而</span><span style="font-family: &apos;Times New Roman&apos;;">map</span><span style="font-family: 宋体;">的查找速度是</span><span style="font-family: &apos;Times New Roman&apos;;">log(n)</span><span style="font-family: 宋体;">级别。并不一定常数就比</span><span style="font-family: &apos;Times New Roman&apos;;">log(n)</span><span style="font-family: 宋体;">小，</span><span style="font-family: &apos;Times New Roman&apos;;">hash</span><span style="font-family: 宋体;">还有</span><span style="font-family: &apos;Times New Roman&apos;;">hash</span><span style="font-family: 宋体;">函数的耗时，明白了吧，如果你考虑效率，特别是在元素达到一定数量级时，考虑考虑</span><span style="font-family: &apos;Times New Roman&apos;;">hash_map</span><span style="font-family: 宋体;">。</span></div><div><span style="font-family: 宋体;">2、但若你对内存使用特别严格，希望程序尽可能少消耗内存，那么一定要小心，</span><span style="font-family: &apos;Times New Roman&apos;;">hash_map</span><span style="font-family: 宋体;">可能会让你陷入尴尬，特别是当你的</span><span style="font-family: &apos;Times New Roman&apos;;">hash_map</span><span style="font-family: 宋体;">对象特别多时，你就更无法控制了，而且</span><span style="font-family: &apos;Times New Roman&apos;;">hash_map</span><span style="font-family: 宋体;">的构造速度较慢。 </span></div><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">现在知道如何选择了吗？权衡三个因素<span style="font-family: &apos;Times New Roman&apos;;">: </span><b><span style="font-family: 宋体;">查找速度</span><span style="font-family: &apos;Times New Roman&apos;;">, </span><span style="font-family: 宋体;">数据量</span><span style="font-family: &apos;Times New Roman&apos;;">, </span></b><span style="font-family: 宋体;"><b>内存使用</b>。</span> </p><p style="color: rgb(51, 51, 51); font-family: Arial; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><span style="font-family: Arial;">8.<span style="font-family: 宋体;">一</span>些使用上的建议：<br/>
Level 3 - <span style="font-family: 宋体;">保存不定长数组，需要动态增加的能力，侧重于寻找数据的速度：采用</span><span style="font-family: &apos;Times New Roman&apos;;">vector（随机访问）</span><br/>
Level 3 - <span style="font-family: 宋体;">保存不定长数组，需要动态增加的能力，侧重于增加删除数据的速度：采用</span><span style="font-family: &apos;Times New Roman&apos;;">list（插入删除）</span><br/>
Level 4 <b>- <span style="font-family: 宋体;">对数据有复杂操作，即需要前后增删数据的能力，又要良好的数据访问速度：采用</span><span style="font-family: &apos;Times New Roman&apos;;">deque（</span></b></span>拥有<span style="font-family: &apos;Times New Roman&apos;;">vector</span>和<span style="font-family: &apos;Times New Roman&apos;;">list</span>两者优点的双端队列<b style="font-family: Arial;"><span style="font-family: &apos;Times New Roman&apos;;">）</span></b></p><p style="color: rgb(51, 51, 51); line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"><font face="Arial">Level 5 -</font> map,set,关联容器：<b>数据有序性、查找平均复杂的O(n)</b>，</p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.399999618530273px; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);"></p><p style="color: rgb(51, 51, 51); font-family: Arial; font-size: 14.399999618530273px; line-height: 26px; text-align: left; background-color: rgb(255, 255, 255);">for_each(obj.begin(),obj.end(),display&lt; 迭代器所指对象 &gt;());</p></div><div><hr/>
0 你为什么要看ＳＴＬ源码呢？<b>（1 方便、健壮、高效；2 提高编码能力）</b></div><div>（1）因为标准模板库是<b>现代Ｃ＋＋程序设计的重要组成部分</b>，也是Ｃ＋＋标准的一部分（还有继承自Ｃ的库）。只有懂得ＳＴＬ模板库，才能够<b>更快设计自己的应用程序（不用重复开发）</b>，以及<b>更加健壮的代码</b>（比如使用vector和数组），以及<b>更加有效率的代码</b>（如果自己开发的应用程序的业务逻辑不符合STL对内存管理哲学，则应该自己设计，如Nginx）。</div><div>（2）通过阅读顶级大师的代码，可以<b>提高自己的编码能力</b>。比如内存池设计，或者以后自己做一些开发项目底层容器时，都可以借鉴这些优良的设计。这么好的设计，学校教C++语言时却一点儿都没涉及。。。</div><div><br/></div><div>1 STL是什么？<b>（1程序库 2 六大组件）</b></div><div>STL简单的说是<b>一套程序库</b>，大致由6个<b>部件</b>组成：空间配置器、容器、算法、迭代器、仿函数、适配器。它对基础的数据结构进行了<b>封装</b>，vector封装了数组，list封装了链表，deque封装了双端队列，set、map封装了二叉排序树，并提供对应数据结构的<b>操作</b>。</div><div>思想：将<span style="color: rgb(255, 0, 0);">数据与操作分离</span>。数据由容器类加以管理，操作由算法定义，迭代器在两者之间充当粘合剂，使任何算法都可以和任何容器交互运作。</div><div><br/></div><div>2 STL构成？</div><div>（1）容器：vector、list、deque、set、map，用class template实现，用来存放数据。</div><div>（2）算法：sort、copy、erase、for_each，用function template实现。</div><div>（3）迭代器：可以理解为“泛型指针”，重载了*，-&gt;，++，--等指针相关操作，所有STL都带有属于自己的专属迭代器。</div><div>（4）仿函数：算法的某种策略选择，重载了（），函数指针可以理解为狭义的仿函数。（函数指针的缺点：无法持有自己的状态和无可配接能力）</div><div>（5）适配器：如stack、queue。</div><div>（6）空间配置器：用于动态空间的分配、管理、释放。</div><div><br/></div><div>3 STL优缺点？（1 可复用 2 效率 3 移植 ）</div><div>优点：</div><div>（1）封装了常用数据结构，<b>避免了重复开发</b>基本功能。</div><div>（2）算法效率高，很大一部分得益于其巧妙的内存池设计。可配置、可复用、可扩展。</div><div>（3）可移植。</div><div>（4）提高程序员的编程效率。</div><div>缺点：</div><div>（1）一旦出错，其抛出的错误提示，很晦涩。</div><div>（2）通用性很强，效率可能有所降低。<br/><br/>
4 空间配置器：主要考虑<b>配置效率 和 内存碎片</b>。核心思想：<b>大内存直接分配和释放，小内存统一申请，统一释放。</b></div><div><br/></div><div>5 迭代器：（<b>隐藏、同一</b>）</div><div>是访问容器的方法，是遍历的一种抽象。好处：<b>不用暴露</b>该容器的内部表达方式，<b>统一</b>了访问容器的接口。<b><font color="#FF0000">在容器和算法之间加了一个中间层（迭代器）</font></b>。</div><div>input iterator:数据的只读访问。</div><div>ouput iterator:数据的只写访问。</div><div>forward iterator:可读可写，向前推进。hashtable</div><div>bidirectional iterator:可读可写，双向推进。list、（set、map，底层都是红黑树，都是利用了红黑树的双向迭代器）</div><div>random iterator:可读可写，随机推荐。vector、deque</div><div><b>任何迭代器类型都应该提供五个内嵌类型。</b></div><div><p>所有容器都提供一些成员函数使我们获得迭代器，最重要的是：</p><p>(1). <strong>begin()</strong> 返回一个迭代器，指向容器的起点，也就是第一个元素的位置。</p><p>(2). <strong>end()</strong> 返回一个迭代器，指向容器结束点，也就是<span style="background-color: rgb(255, 255, 102);">最后一个元素之后的位置</span>。</p><p>(1). <strong>rbegin()</strong> 返回一个迭代器，指向容器最后一个元素的位置。</p><p>(2). <strong>rend()</strong> 返回一个迭代器，指向容器<span style="background-color: rgb(255, 255, 102);">第一个元素之前的位置</span>。</p></div><div><br/></div><div>6 traits编程技术：用于获取迭代器 所指对象的 <b>类型信息</b>。利用了<b>“内嵌类型”</b>的编程技巧 和 编译器的<b>template参数推导</b>功能。比如在实现迭代器中 <b>T&amp;</b> operator*（）const{}时就要返回 T&amp;，<b><font color="#FF0000">在迭代器和迭代器所指对象类型之间加了一个中间层（iterator_traits&lt;I&gt;）</font></b>。</div><div><br/></div><div>7 容器（<b>序列式容器、关联式容器、容器适配器</b>）</div><div>vector：</div><div>list：</div><div>deque：没有容量的观念，动态的以<b>分段连续空间组合而成</b>，随时可以增加一段新的空间并链接起来。</div><div>stack：可以将deque或者list作为底层容器。</div><div>queue：无迭代器。</div><div>heap：无迭代器。底层可为vector</div><div>priority_queue:无迭代器。底层默认为vector。有push()、pop()、top()等操作。</div><div>set：<br/><hr/></div><div>访问函数总结：<br/></div><div><div>一、顺序容器</div><div><b><font color="#FF0000">container_type&lt;T&gt;::iterator iter;或者 container_type&lt;T&gt;::const_iterator citer;</font></b></div><div><b><font color="#FF0000">for(iter = obj.begin();iter != obj.end();++iter)</font></b></div><div><b><font color="#FF0000">{</font></b></div><div><b><font color="#FF0000">}</font></b></div><div><b><font color="#FF0000">迭代器指向末尾时，如 pcur = src.end(); <strike>不可以再用 pcur++;</strike> 要用pcur = src.begin() 进行更新。</font></b></div><div>1、构造</div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">C&lt;T&gt; c</td></tr><tr><td valign="top">C&lt;T&gt; c(c2)</td></tr><tr><td valign="top">C&lt;T&gt; c(b,e)</td></tr><tr><td valign="top">C&lt;T&gt; c(n,t)</td></tr><tr><td valign="top">C&lt;T&gt; c(n)  关联容器不行</td></tr></tbody></table><div><br/></div><div>2、容器定义的类型别名</div><div>size_type,无符号类型</div><div>iterator,const_iterator,reverse_iterator,const_reverse_iterator,</div><div>difference_type,足够存储两个迭代器差值的有符号整型</div><div>value_type,</div><div>reference,const_reference</div><div><br/></div><div>3、插入</div><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">c.push_back(t)</td><td valign="top"><br/></td></tr><tr><td valign="top"><font color="#FF0000"><b>c.push_front(t)</b></font></td><td valign="top"><font color="#FF0000"><b>只适用list、deque</b></font></td></tr><tr><td valign="top">c.insert(p,t)</td><td valign="top">在迭代器<b>p前</b>插入</td></tr><tr><td valign="top">c.insert(p,n,t)</td><td valign="top">n个t的值</td></tr><tr><td valign="top">c.insert(p,b,e)</td><td valign="top">在p位置前面插入[b,e)</td></tr></tbody></table><div><br/></div><div>4、删除</div><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">c.erase(p)</td><td valign="top">删除p指的元素，<b>返回下一个元素迭代器</b>，p != end()<br/><b>若是环，要用p = obj.begin(),使它指向头结点。</b></td></tr><tr><td valign="top">c.erase(b,e)</td><td valign="top">[b,e)</td></tr><tr><td valign="top">c.remove(value)</td><td valign="top">删除所有值为value的结点</td></tr><tr><td valign="top">c.clear()</td><td valign="top">删除所有</td></tr><tr><td valign="top">c.pop_back()</td><td valign="top">删除最后一个元素 不能为空</td></tr><tr><td valign="top"><font color="#E30000">c.pop_front()</font></td><td valign="top"><font color="#E30000">只适用list,deque</font></td></tr></tbody></table><div><br/></div></div><div>5、访问</div><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">c.front(),c.back()</td><td valign="top"><br/></td></tr><tr><td valign="top"><font color="#E30000">c[n]</font></td><td valign="top"><font color="#E30000">只适用vector和deque</font></td></tr><tr><td valign="top"><font color="#E30000">c.at(n)</font></td><td valign="top"><font color="#E30000">返回下标为n元素的引用<br/></font><div><font color="#E30000">只适用vector和deque</font></div></td></tr></tbody></table><div><br/></div></div><div>6、容器大小</div></div><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">c.size()</td><td valign="top">返回容器中已有元素个数</td></tr><tr><td valign="top">c.max_size()</td><td valign="top"><br/></td></tr><tr><td valign="top">c.empty()</td><td valign="top"><br/></td></tr><tr><td valign="top">c.resize(n)</td><td valign="top"><br/></td></tr><tr><td valign="top">c.resize(n,t)</td><td valign="top">调整为n大小，新添加元素为t</td></tr></tbody></table><div><br/></div></div><div>7、赋值和swap</div><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">c1 = c2</td><td valign="top"><br/></td></tr><tr><td valign="top">c1.swap(c2)</td><td valign="top"><br/></td></tr><tr><td valign="top">c.assign(b,e)</td><td valign="top">重新设置c的元素，用区间[b,e),该区间不指向c</td></tr><tr><td valign="top">c.assign(n,t)</td><td valign="top">n个值为t</td></tr></tbody></table></div></div><div><br/></div><hr/></div><div><p><strong>Value 与 Reference</strong></p><p>所有容器都会建立元素副本，并返回该副本。这意味着 STL 只提供 Value 语意。</p><p>STL 只支持 Value 语意，不支持 Reference 语意。如果你想要支持 Reference 语意，你可以用指针作为元素来实现，但是要非常谨慎。</p><p style="background-color:rgb(255,204,204)"><strong>七. 错误与异常</strong></p><p><strong>1. 错误处理</strong></p><p>STL 的设计原则是效率优先，安全次之。而错误检查相当花时间，所以在 STL 里<span style="color:#FF0000; background-color:rgb(255,255,102)">几乎没有错误处理</span>。<br/></p><p>所以对操作人员来说，要自己保证使用 STL 的正确性，或者自己增加一层包装来实现STL的安全性。</p><p><strong>2. 异常处理</strong></p><p>(1). 所有以节点实现的容器，如 list， set， multiset， mpa， multimap，如果节点构造失败，容器保持不变。</p><p>(2). 移除(removing)节点的动作保证不会失败。</p><p>(3). 对关联式容器插入(insert)多个元素，如果失败，则无法完全恢复原状。</p><p>(4). 对关联式容器插入单一个元素，要么成功，要么没有任何影响。<br/></p><p>(5). 所有擦除(erase)操作，无论是针对单一元素或针对多重元素，肯定会成功。</p><p>(6). vector，deques类型的容器，在安插(insert)元素时如果失败，都不可能做到完全回复。</p></div><div><br/></div><div>一 <a href="http://blog.csdn.net/xiajun07061225/article/details/7438361">容器的共通能力和共通操作总结</a></div><div><p>其中三个最核心的能力是：</p><p><strong><span style="color:#ff0000">（1）所有容器提供的是“value语意”而不是“reference语意”。--存储过程</span></strong></p><p>容器进行元素的安插操作时，内部实施的是拷贝操作，存放的是元素的副本。<strong>因此容器的每一个元素必须能被拷贝</strong>。</p><p><strong>如果打算存放的对象不具备public 拷贝构造函数或者你要得不是对象的副本，那么容器元素只能是指针</strong>。</p><p><strong><span style="color:#ff0000">（2）所有元素形成一个次序。--访问过程</span></strong></p><p>我们可以以相同顺序一次或者多次遍历每个元素。每个容器都提供可返回迭代器的函数，运用这些迭代器可以遍历元素。</p><p><strong><span style="color:#ff0000">（3）一般来说，各项操作并非绝对安全。--操作的安全性</span></strong></p><div>调用者必须确保传给操作函数的参数符合需求。违反需求的会导致未定义的行为。而且STL通常不会自己跑出异常。</div></div><div><br/></div><div><p><span style="font-size:24px; color:rgb(255,0,0)"><strong><span style="font-family:KaiTi_GB2312">二、容器的共通操作</span></strong></span></p><p>下表列出容器的共通操作函数：</p><div><img src="http://my.csdn.net/uploads/201204/08/1333882806_1355.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img></div></div><div><p><strong><span style="font-family:&amp;amp;amp;amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;amp;amp;amp;apos;; color:#ff0000">（1）初始化</span></strong></p><p>每个容器类别都提供了一个默认构造函数、一个拷贝构造函数和一个析构函数。</p><p>以另一个容器的元素为初值，进行初始化：</p><p>list&lt;int&gt; intList;<br/>
vector&lt;float&gt; floatVec(intList.begin(),intList.end());<br/></p><p>以一个数组的元素为初值进行初始化：</p><p>int array[] = {1,2,3,4,5};<br/>
set&lt;int&gt; intSet(array,array + sizeof(array) / sizeof(array[0]));<b><font color="#FF0000">//原始指针作为迭代器</font></b><br/></p><p>从标准输入获取元素进行初始化：</p><p>deque&lt;int&gt; c((istream_iterator&lt;int&gt;(cin)),<br/><font color="#FF0000">(<b>istream_iterator&lt;int&gt;()</b>));//定义输入流结束迭代器，需包含#include&lt;iterator&gt;</font><br/></p><p>注意：不能遗漏了初始化参数的那对多余的括号：<br/>
不能是这样的：<br/>
deque&lt;int&gt; c(istream_iterator&lt;int&gt;(cin),<br/>
istream_iterator&lt;int&gt;());<br/><br/>
否则，表达式被认为是一个函数c的声明。它的一个参数的型别是istream_iterator&lt;int&gt;，参数名是cin。第二个参数无 名，型别是istream_iterator&lt;int&gt;。函数的返回值型别是istream_iterator&lt;int&gt;。<br/>
但是，我们通过加上一对括号，就可以使参数istream_iterator&lt;int&gt;(cin)不再符合声明语法。</p><p>因为C++标准中的语法不接受这样的函数声明形式：</p><p><strong><span style="color:#009900">T name((U), (V));</span></strong><br/></p><p><strong><span style="font-family:&amp;amp;amp;amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;amp;amp;amp;apos;; color:#ff0000">（2）与大小相关的操作函数</span></strong></p><p>1、size()</p><p>返回当前元素的数量</p><p>2、empty()</p><p>等价于size() == 0.但是其效率可能会高些。所以应该尽量使用empty()。</p><p>3、max_size()</p><p>返回容器所能容纳的最大元素数量。其值会因实作版本不同而不同。</p><p><strong><span style="font-family:&amp;amp;amp;amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;amp;amp;amp;apos;; color:#ff0000">（3）比较</span></strong></p><p>包括常用的==，!=,&lt;,&lt;=,&gt;,&gt;=。</p><p>注意：比较操作的两端即两个容器必须属于同一型别。如果容器的所有元素依次序相等，则两个容器相等。采用operator==检查元素是否相等。采用字典式书序比较原则来判断某个容器是否小于另一个容器。</p><p><strong><span style="font-family:&amp;amp;amp;amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;amp;amp;amp;apos;; color:#ff0000">（4）赋值和swap交换</span></strong></p><p>当对容器赋值元素时，源容器的所有元素被拷贝到目标容器内，后者的所有元素完全被移除。所以，赋值操作代价较高。</p><p>如果两个容器的型别相同，而且拷贝后源容器不在使用，可以使用swap进行优化。它的性能要优异很多。事实上它只交换某些内部指针，所以时间复杂度是常数，而赋值操作的复杂度是线性的。</p></div><div><hr/><hr/><p><span style="font-family:KaiTi_GB2312; font-size:32px; color:#ff0000"><strong>一、list基础</strong></span></p><p>List使用一个双向链表来管理元素。图一显示了list的结构。</p><p style="text-align:center"><img src="http://my.csdn.net/uploads/201204/13/1334318414_7212.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p style="text-align:center">图一 list的结构</p><p>任何型别只要具备赋值和可拷贝两种性质，就可以作为list的元素。</p><p><span style="font-family:KaiTi_GB2312; font-size:32px; color:#ff0000"><strong>二、list的功能</strong></span></p><p>list的内部结构和vector和deque截然不同，在很多方面都表现不同：</p><p>1、list不支持随机存取。所及既不提供下表操作符，也不提供at()函数。</p><p>2、任何位置上插入元素删除元素都很快。</p><p>3、插入和删除操作<b>不会造成指向其他元素的pointers、references、iterators失效。</b></p><p>4、list对于异常的处理方式是：要么成功，要么什么都不发生。</p><p>5、不提供容量、空间重新分配等操作函数。</p><p>6、提供了一些函数专门用于移动元素。</p><p><span style="font-family:KaiTi_GB2312; font-size:32px; color:#ff0000"><strong>三、list的操作函数</strong></span></p><p>生成、赋值和销毁与序列式容器相同。</p><p><strong><span style="color:#ff0000">构造函数和析构函数：</span></strong></p><p><img src="http://my.csdn.net/uploads/201204/13/1334318872_3818.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p><strong><span style="color:#ff0000">非变动性操作</span></strong></p><p><img src="http://my.csdn.net/uploads/201204/13/1334318950_1589.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p><strong><span style="color:#ff0000">赋值</span></strong></p><div><b><img src="http://my.csdn.net/uploads/201204/13/1334318975_6397.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></b></div><div><b>注意assign()、swap();</b></div><p><strong><span style="color:#ff0000">元素存取</span></strong></p><p><img src="http://my.csdn.net/uploads/201204/13/1334318998_8453.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p><b>一般来说，这些操作不会检查元素是否为空，所以程序员必须保证容器不为空。</b></p><p><strong><span style="color:#ff0000">迭代器相关函数</span></strong></p><p>存取元素只能用迭代器。然而由于<b>list不能随机存取</b>，这些迭代器只<b>是双向而非随机迭代器</b>。所以凡是用到随机存取迭代器的算法（所有用来操作元素顺序的算法-特别是排序算法都归于此类）都不能调用。不过可以用<b><font color="#FF0000">list的成员函数sort()完成此功能,而不是用全局的sort()函数</font></b>。</p><p><img src="http://my.csdn.net/uploads/201204/13/1334319172_1460.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p><strong><span style="color:#ff0000">元素的插入和删除</span></strong></p><p><img src="http://my.csdn.net/uploads/201204/13/1334319233_1663.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p><img src="http://my.csdn.net/uploads/201204/13/1334319248_8916.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p>list提供deque的多余功能，还增加了remove()和remove_if()算法应用于list‘身上的特殊版本。这些成员函数比STL的remove算法更快，因为它们只进行内部指目标工作，无需估计元素。</p><p>要将所有与某值相等的元素删除，可以用如下语句（注意：确实是将这些元素删除了，而不是像vector那样只是某种移动而已）</p><div><ol start="1"><li>list&lt;int&gt; list1;  </li><li>list1.remove(val);  </li></ol></div>
list还提供了其他一些成员函数，用来改变元素和区间的次序，或是重新串链。我们可以用他们来移动单一list里的元素，也可以移动两个list之间的元素（前提是list的型别一致）。
<p><img src="http://my.csdn.net/uploads/201204/13/1334319718_6094.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img></p><p><span style="font-family:KaiTi_GB2312; font-size:32px; color:#ff0000"><strong>四、list的异常处理</strong></span></p><p>在所有的STL标准容器中，list提供了最佳支持。几乎所有的操作都是要么正确，要么什么都不发生。只有少数几个操作没有这样的保证：赋值和 sort()。不过他们也不会泄露资源，也不会与容器的恒常特性发生冲突。merge(),remove(),remove_if(),unique() 提供的保证是有前提的L就是元素间的比较动作不会抛出异常。</p><hr/><hr/></div><div style="font-size: 24px;"><b><font color="#FF4635">三 deque双端队列</font></b></div><div style="font-size: 24px;"><b><font color="#FF0000"><br/></font></b></div><div><b><font color="#FF0000">1 deque提供随机访问迭代器，但是与vector有着本质区别，不是普通指针，所以效率没有vector高。</font></b></div><div><b><font color="#FF0000">2 deque提供的是分段连续空间，维持其“整体连续”的假象，由迭代器 operator++和operator--提供。</font></b></div><div><br/></div><div><p><strong><span style="font-family:&amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;apos;; color:#ff0000">deque的逻辑结构：</span></strong></p><p><img src="http://my.csdn.net/uploads/201204/09/1333979310_4087.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p><br/></p><p><span style="font-family:&amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;apos;; color:#ff0000"><strong>deque的内部结构</strong></span></p><p>deque是一种优化了的对序列两端元素进行添加和删 除操作的基本序列容器。通常由一些独立的区块组成，第一区块朝某方向扩展，最后一个区块朝另一方向扩展。它允许较为快速地随机访问但它不像vector一 样把所有对象保存在一个连续的内存块，而是多个连续的内存块。并且在一个映射结构中保存对这些块以及顺序的跟踪。</p><p>其内部结构如下图所示：</p><p><img src="http://my.csdn.net/uploads/201204/09/1333979333_4240.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img><br/></p><p><span style="font-family:&amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;apos;; color:#ff0000"><strong>deque的特点：</strong></span></p><p>1、支持随机访问，即支持[]以及at()，但是性能没有vector好。</p><p>2、可以在内部进行插入和删除操作，但性能不及list。</p><p><br/></p><p><span style="font-family:&amp;amp;amp;apos;Microsoft YaHei&amp;amp;amp;apos;; color:#ff0000"><strong><span style="font-size:18px">deque和vector的不同之处：</span></strong></span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">1</span>、两端都能够快速插入和删除元素。<span lang="EN-US">vector</span>只能在尾端进行。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">2</span>、<span lang="EN-US">deque</span>的元素存取和迭代器操作会稍微慢一些。因为<span lang="EN-US">deque</span>的内部结构会多一个间接过程。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">3</span>、迭代器是特殊的智能指针，而不是一般指针。它需要在不同的区块之间跳转。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">4</span>、<span lang="EN-US">deque</span>可以包含更多的元素，其<span lang="EN-US">max_size</span>可能更大。因为不止使用一块内存。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">5</span>、不支持对容量和内存分配时机的控制。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px">注意：在除了首尾两端的其他地方插入和删除元素，都将会导致指向<span lang="EN-US">deque</span>元素的任何<span lang="EN-US">pointers</span>、<span lang="EN-US">references</span>、<span lang="EN-US">iterators</span>失效。不过，<span lang="EN-US">deque</span>的内存重分配优于<span lang="EN-US">vector</span>。因为其内部结构显示不需要复制所有元素。</span></p><div><span style="font-size:16px"><span lang="EN-US">6</span>、<span lang="EN-US">deque</span>的内存区块不再被使用时，会被释放。<span lang="EN-US">deque</span>的内存大小是可缩减的。不过，是不是这么做以及怎么做由实作版本定义。</span></div><div><span style="font-size:16px">7、避开了想vector那样“重新配置、复制、释放”的操作，代价则是复杂的迭代器架构。</span></div><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span lang="EN-US" style="font-size:7pt"> </span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:18px"><strong><span style="color:#ff0000"><span lang="EN-US">deque</span>和<span lang="EN-US">vector</span>相似的特性：</span></strong></span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">1</span>、在中间部分插入和删除元素相对较慢，因为所有元素都要被移动。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">2</span>、迭代器属于随即存取迭代器。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span lang="EN-US"><span style="font-size:18px"> </span></span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:18px"><strong><span style="color:#ff0000">最好采用<span lang="EN-US">deque</span>的情形：</span></strong></span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">1</span>、需要在两端插入和删除元素。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">2</span>、无需引用容器内的元素。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">3</span>、要求容器释放不再使用的元素。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span lang="EN-US" style="font-size:7pt; font-family:Arial,sans-serif"> </span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-weight:bold"><span style="font-family:KaiTi_GB2312; color:rgb(255,0,0)"><span style="font-size:24px"><span lang="EN-US">deque</span>的操作函数</span></span></span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:18px"><strong><span style="color:#ff0000">构造函数和析构函数：</span></strong></span></p><p><font size="4"><br/></font></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:18px"><strong><span style="color:#ff0000">非变动性操作：</span></strong></span></p><span style="font-size:18px"><br/></span><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:18px"><strong><span style="color:#ff0000">变动性操作：</span></strong></span></p><span style="font-size:18px"><br/></span><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span lang="EN-US"><span style="font-size:16px">deque的各项操作只有一下两点和vector不同：</span></span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">deque</span>不提供容量操作：<span lang="EN-US">capacity()</span>和<span lang="EN-US">reverse()</span>。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px"><span lang="EN-US">deque</span>直接提供函数完成首尾元素的插入和删除。</span></p><p style="margin-top:2.3pt; margin-right:0cm; margin-bottom:2.3pt; margin-left:0cm; background:white"><span style="font-size:16px">其他均与<span lang="EN-US">vector</span>相同。</span></p><span style="font-size:16px">注意：</span><p><span style="font-size:16px">1、除了at()函数，其他成员函数都不会检查索引或迭代器是否有效。</span></p><p><span style="font-size:16px">2、元素的插入和删除可能会导致内存重新分配。所以任何插入或删除操作都会使所有指向deque元素的pointers、reference、iterators失效。唯一例外的是在首尾插入元素之后，pointers和reference可能仍然有效。</span></p><p><br/></p></div><div><font color="#FF0000" face="KaiTi_GB2312" size="6"><b>五、set与multiset、map与multimap</b></font></div><div>关联容器：通过<b><font color="#FF0000">键（与顺序容器最大的区别）</font></b>来存储和读取元素。</div><div>特点：自动排序的优点是使得搜索元素时具有良好的性能。</div><div><br/></div><div>set：只是单纯的键集合。当只想知道一个值是否存在时，使用set即可。不支持下标操作符。</div><div>multiset:</div><div><br/></div><div>map:键值对的集合。可以理解成<b>关联数组</b>。</div><div><br/></div><div>multimap:允许一个键对应多个值。不支持下标操作</div><div><p><strong><span style="color:#ff0000">特殊的搜寻函数</span></strong></p><p style="text-align:center"><img src="http://my.csdn.net/uploads/201204/13/1334325660_8442.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img></p><p><img src="http://my.csdn.net/uploads/201204/13/1334325670_8888.jpg" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;"></img></p></div><div><br/></div><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">vector<br/><div align="left"><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">template</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">&lt;</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">typename</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T&gt;</span></font></div><div align="left"><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">class</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">Vector{</span></font></div><div align="left"><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">public</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">:</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//内嵌类型</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">typedef</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T value_type;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">typedef</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">value_type* pointer;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">typedef</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">value_type&amp; reference;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">typedef</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">value_type* iterator;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">typedef</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">size_t size_type;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">typedef</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">ptrdiff_t difference_type;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//构造函数，赋值函数</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          Vector():start(0),finish(0),end_of_storage(0){}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          Vector(</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">int</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">n,</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T&amp; value){fill_initialize(n,value);}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          Vector(</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">long</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">n,</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T&amp; value){fill_initialize(n,value);}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">explicit</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">Vector(</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">int</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">n){fill_initialize(n,T())}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">Vector&lt;T&gt;&amp;</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">operator</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">=(</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">Vector&lt;T&gt;&amp; rhs){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">/*</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   1 先判断是否为同一个对象</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   2 判断两个vector的空间关系</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                             rhs是否为空==》直接clear()</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                             rhs是否比左边的size()空间小==》拷贝，删除，更新finish、end_of_storage</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                             rhs是否比左边的capacity()空间小==》先拷贝，删除，更新finish、end_of_storage</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                             rhs是否比左边的大==》删除原来的，重新分配，拷贝，更新</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   */</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//插入、删除、访问</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">insert(iterator position,size_type n,</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T&amp; x){};</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">push_back(</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T&amp; x){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">if</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(finish != end_of_storage){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">new</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(finish) T(x);</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             ++finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   }</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">else</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">{</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             insert_aux(x);</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">pop_back(){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   --finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">delete</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          iterator erase(iterator position){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//删除Position指向的元素</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">/*</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   1 若Position所指元素为最后一个</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   2 若Position所指向中间的结点，则先移动元素，变成第一种情况</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   */</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">if</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(position + 1 == end()){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">for</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(iterator it = position;it != end()-1;++it)</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                                      *it = *(it+1);</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   --finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">delete</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">return</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">position;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          iterator erase(iterator first,iterator last){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//删除[first,last)里的元素</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">/*</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   1 拷贝、移动</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   2 删除[it,finish)</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   3 调整finish指针</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   4 返回</span></font></div><div align="left"><font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">                   */</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">if</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(first == NULL)</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">return</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">first;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   iterator it = copy(last,finish,first);</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">for</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(iterator t = it;t != finish;++t)</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">if</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(it != NULL)</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                                      </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">delete</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">it;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   finish = it;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">return</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">first;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">clear(){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   erase(begin(),end());</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          reference</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">operator</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">[](size_type n){*(begin()+n);}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//三个迭代器简单应用</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          iterator begin(){</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">return</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">start;}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          iterator end(){</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">return</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">finish;}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          size_type size(){</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">return</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">size_type(end()-begin());}</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//其它操作</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">resize(size_type new_size){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">if</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(new_size &lt; size()){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             erase(begin()+new_size,end());</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   }</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">else</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">{</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             insert(end(),new_size-size(),T());</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt"><br/></span></font></div><div align="left"><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">protected</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">:</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//辅助函数</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">fill_initialize(size_type n,</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T&amp; value){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   start =</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">new</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T[n];</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   iterator tmp = start;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">for</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">int</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">i = 0;i &lt; n;i++){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">new</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(tmp) T(value);</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             ++tmp;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   finish = start + n;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   end_of_storage = finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">insert_aux(</span></font><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T&amp; x){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">size_type oldsize = size();</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">const</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">size_type len = oldsize != 0 ? 2*oldsize : 1;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//配置新空间</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   iterator new_start =</span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">new</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">T[len];</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   iterator new_finish = new_start;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//拷贝元素</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   new_finish = copy(begin(),end(),new_start);</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">new</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">(new_finish) T(x);</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   ++new_finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//没有考虑insert（）函数插入带来的空间不足的处理</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//删除原来的</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   destroy(begin(),end());</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//调整 start，finish，end_of_storage</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   start = new_start;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   finish = new_finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   end_of_storage = new_start + len;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">void</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">destroy(iterator first,iterator last){</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                   </span></font> <font color="#008000" face="Times New Roman" size="4"><span style="font-size:14pt">//for(iterator it=first;it != last;++it)</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">                             </span></font> <font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">delete</span></font> <font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">[] first;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          }</span></font></div><div align="left"><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">protected</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">:</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          iterator start;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          iterator finish;</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">          iterator end_of_storage;</span></font></div><div align="left"><font color="#0000FF" face="Times New Roman" size="4"><span style="font-size:14pt">private</span></font><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">:</span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt"><br/></span></font></div><div align="left"><font color="#010101" face="Times New Roman" size="4"><span style="font-size:14pt">};</span></font></div></td></tr></tbody></table><div><br/></div></div><div><br/></div><div><br/></div></div>
</div></body></html> 